{"Quantum-Information/Distances/Bures-distance":{"slug":"Quantum-Information/Distances/Bures-distance","filePath":"../PhysicsVault/Quantum Information/Distances/Bures distance.md","title":"Bures distance","links":["Quantum-Information/Distances/Fidelity"],"tags":[],"content":"The Bures distance is a distance derived from the notion of Fidelity\nD_{B} (\\rho_1,\\rho _2) \\equiv \\sqrt{2} \\sqrt{1-\\sqrt{F(\\rho_1,\\rho _2) }}\nsee Holevo’s book, page 200 for further details.\nThe Bures distance is considered useful in the context of quantum metrology."},"Quantum-Information/Distances/Fidelity-and-Trace-Distance-connection":{"slug":"Quantum-Information/Distances/Fidelity-and-Trace-Distance-connection","filePath":"../PhysicsVault/Quantum Information/Distances/Fidelity and Trace Distance connection.md","title":"Fidelity and Trace Distance connection","links":["Quantum-Information/Distances/Fidelity","Quantum-Information/Distances/Trace-Distance"],"tags":[],"content":"Useful relation between the notions of Fidelity and Trace Distance:\n1-\\sqrt{F(\\rho_1,\\rho _2)} \\leq D(\\rho_1,\\rho _2) \\leq\\sqrt{1-F(\\rho_1,\\rho _2) }\nFor a proof see Holevo’s book, page 195."},"Quantum-Information/Distances/Fidelity":{"slug":"Quantum-Information/Distances/Fidelity","filePath":"../PhysicsVault/Quantum Information/Distances/Fidelity.md","title":"Fidelity","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Trace-norm","Quantum-Information/Open-system-dynamics/Quantum-channels"],"tags":[],"content":"Fidelity is kind of like the opposite of distance; the fidelity between two states \\rho _1,\\rho_2 is often defined by:\nF(\\rho_1,\\rho _2) \\equiv \\norm{\\sqrt{\\rho _1}\\sqrt{\\rho _2}}^2 _1\nor by its square root (not used here). The \\norm{\\cdot}_1 is the Trace norm operation.\nF(\\rho_1,\\rho _2) =\\left(\\tr\\sqrt{\\sqrt{\\rho _1}\\rho _2\\sqrt{\\rho _2}}\\right)^2\nProperties\n\nSince\n\\norm{\\theta}_1 = \\norm{\\theta ^\\dagger}_1\nThe fidelity is symmetrical in its inputs\n\nF(\\rho_1,\\rho _2) =F(\\rho_2,\\rho _1)\n\nThe fidelity hits its maximum when the two states are identical\n\nF(\\rho,\\rho) = 1\n\nIf \\rho _1 \\rho _2 = \\rho _2 \\rho _1 = 0, then the fidelity is null.\nUnder Quantum channels, the fidelity is monotonous non-decreasing:\nF(\\rho_1,\\rho _2) \\leq F(\\Phi (\\rho_1),\\Phi(\\rho _2))\nThis makes sense as LCPT maps add noise to the system, making it less distinguishable. Unitary maps saturate the relation above.\n\nFidelity with pure state\nIf one of the states, e.g. \\rho _1, is a pure state:\n\\rho _1 = \\op{\\psi}{\\psi}\nThen the fidelity reduces to\nF(\\op{\\psi }{\\psi },\\rho ) = \\ev{\\psi}{\\rho}\nsee fidelity on Holevo’s book."},"Quantum-Information/Distances/Kolmogorov-distance":{"slug":"Quantum-Information/Distances/Kolmogorov-distance","filePath":"../PhysicsVault/Quantum Information/Distances/Kolmogorov distance.md","title":"Kolmogorov distance","links":[],"tags":[],"content":"The Kolmogorov distance measures how much two probability distribution differ from each other; given the probability distributions\n\\{p_x\\}_x,\\{q_x\\}_x\nthe Kolmogorov is defined as:\nD_K \\left(\\{p\\}\\{q\\}\\right) \\equiv \\frac{1}{2}\\sum _x\\abs{p_x-q_x}"},"Quantum-Information/Distances/Qubit-distance":{"slug":"Quantum-Information/Distances/Qubit-distance","filePath":"../PhysicsVault/Quantum Information/Distances/Qubit distance.md","title":"Qubit distance","links":["Quantum-Information/Foundations/Qubits"],"tags":[],"content":"In the case of Qubits, using the Bloch sphere representation, we can define a notion of distance:\n\\rho _i =\\frac{1}{2}\\left(\\id + \\vec{r}_i\\cdot\\vec{\\sigma}\\right)\nD(\\rho _1,\\rho _2) = \\frac{1}{2} \\abs{\\vec{r}_1-\\vec{r}_2}"},"Quantum-Information/Distances/Trace-Distance":{"slug":"Quantum-Information/Distances/Trace-Distance","filePath":"../PhysicsVault/Quantum Information/Distances/Trace Distance.md","title":"Trace Distance","links":["Quantum-Information/Foundations/Trace-norm","Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Distances/Kolmogorov-distance","Quantum-Information/Measurements/POVM's","Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Measurements/Helstrom's-theorem"],"tags":[],"content":"The trace distance draws from the Trace norm to define a notion of distance; given two Density matrix operators \\rho_1,\\rho_2, their trace distance is defined as:\nD(\\rho _1,\\rho _2) \\equiv \\frac{1}{2}\\norm{\\rho _1-\\rho _2}_1\nwhere \\norm{\\cdot}_1 is the trace norm.\nThe trace distance is considered useful for dealing with decision problems (e.g. discriminating between two states)\nAlternative form\nAn alternative form for the trace distance, useful in many proofs, is:\nD(\\rho _1,\\rho _2) = \\max_\\Pi\\tr\\left(\\Pi (\\rho _1-\\rho _2)\\right)\nwhere \\Pi indicates projectors.\nProof\n\nParallelism with Kolmogorov distance\nIn the special case of commuting operators:\n[\\rho _1,\\rho _2] = 0\nThe trace distance reduces to the Kolmogorov distance, which can be proven by direct computation in the common eigenbasis of the two operators.\nThis allows us to kind of think of statistical mechanics as the abelian quantum statistical mechanics.\nPOVM’s\nAnother connection with the Kolmogorov distance arises from the POVM formalism. Operationally, if we build an appropriate measurement device, the trace distance reduces to the Kolmogorov distance.\nGiven two density matrices \\rho _1,\\rho _2 and a POVM \\{E_n\\} describing a measurement device, two probability distributions arise from the measurements:\np_n ^{(1)} = \\tr(E_n \\rho _1)\\rightarrow \\{p_n ^{(1)}\\}_n\np_n ^{(2)} = \\tr(E_n \\rho _2)\\rightarrow \\{p_n ^{(2)}\\}_n\nwe can define a concept of distance between states given the measurement device, which is the Kolmogorov distance between the probability distributions defined above:\nD_{\\{E_n\\}_n}(\\rho _1,\\rho_2) = D_K\\left(\\{p_n ^{(1)}\\}_n,\\{p_n ^{(2)}\\}_n\\right)\nIt turns out that, if we select the optimal measurement device, this distance reduces to the trace distance:\n\\max_{\\{E_n\\}_n}D_{\\{E_n\\}_n}(\\rho _1,\\rho_2) = D(\\rho _1,\\rho _2)\nProof\n\nProperties\n\nThe trace distance is non-negative and is 0 only when the operators are the same:\n\nD(\\rho _1,\\rho _2)\\geq 0\\qquad D(\\rho _1,\\rho _2) = 0\\Leftrightarrow \\rho _1 = \\rho _2\n\nThe trace distance of orthogonal states is 1:\n\n\\rho_1\\rho _2= \\rho _2\\rho _1 = 0\\Rightarrow D(\\rho _1,\\rho _2) =1\n\nThe trace distance is commutative\n\nD(\\rho _1,\\rho _2) = D(\\rho _2,\\rho _1)\n\nThe trace distance satisfies the triangular inequality\nD(\\rho _1,\\rho _2) \\leq D(\\rho _1,\\rho _3)+D(\\rho _3,\\rho _2)\nwhich can be proven using the projection form for the trace distance\nUnder unitary channels \\mathcal{V}, the trace distance is constant\nD(\\mathcal{V}(\\rho _1),\\mathcal{V}(\\rho _2)) = D(\\rho _1,\\rho _2)\nGenerally, however, quantum channels \\Phi contract the trace distance\nD(\\Phi(\\rho _1),\\Phi(\\rho _2)) \\leq D(\\rho _1,\\rho _2)\nthis can be proven following the same formalism as the one used for the proof of the alternative form of the trace distance:\n\n\\rho _1-\\rho _2 \\equiv A-B\nD(\\rho _1,\\rho _2) = \\max_{\\Pi} \\tr (\\Pi (\\rho _1 -\\rho _2)) = \\tr (A)\n\\begin{split}D(\\Phi(\\rho _1),\\Phi(\\rho _2)) &amp; = \\max_{\\Pi} \\tr (\\Pi \\Phi(\\rho _1 -\\rho _2)) \\\\ &amp;\\leq \\max_{\\Pi} \\tr (\\Pi \\Phi(A))\\leq\\tr ( \\Phi(A))\\leq \\tr (A)\\end{split}\n\nGiven two joint states \\rho _{AB}, \\sigma _{AB} such that their reduced density matrices are \\rho _A = \\tr _B\\rho _{AB}, \\sigma _A = \\tr _B\\sigma _{AB}:\nD(\\rho _{AB},\\sigma _{AB}) \\geq D(\\rho _A,\\sigma _A)\nwhich makes sense as in the partial trace operation we are losing information on the system B. This property can be proven using the previous property and selecting the channel\n\\Phi: \\rho _{AB}\\overset{\\Phi}{\\mapsto}\\rho _A\\otimes \\ket{0}_B\\bra{0}\nor using the fact that the partial trace is a proper quantum channel\n\nHelstrom theorem\nThere is an operational connection from the trace distance definition to the “real world” through the Helstrom’s theorem. In fact, in the case where we work in an ensemble of 2 states on which we have no information regarding the associated probability distribution, we suppose that the two states are chaotically created (50% rate) and the minimum probability of error for distinguishing them becomes:\n\\min P_{error} = \\frac{1}{2} \\left(1-\\frac{1}{2} \\norm{\\rho _1 - \\rho _2}_1\\right) =\\frac{1}{2} \\left(1-D(\\rho _1,\\rho _2)\\right) "},"Quantum-Information/Distances/Uhlmann-theorem":{"slug":"Quantum-Information/Distances/Uhlmann-theorem","filePath":"../PhysicsVault/Quantum Information/Distances/Uhlmann theorem.md","title":"Uhlmann theorem","links":["Quantum-Information/Distances/Fidelity","Quantum-Information/Foundations/Purification","Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Schmidt-decomposition","Quantum-Information/Foundations/Orthogonality-relation-for-unitaries"],"tags":[],"content":"Uhlmann theorem connects the notions of Fidelity and Purification.\nSuppose we have two states \\rho _1,\\rho _2 in the system S, and suppose we purify them using a reference system R.\n\\rho _1 \\mapsto \\ket{\\psi _1}_{SR}\n\\rho _2 \\mapsto \\ket{\\psi _2}_{SR}\nThen, the fidelity between the two states is:\nF(\\rho_1,\\rho _2) = \\max_{ \\ket{\\psi _1}_{SR}, \\ket{\\psi _2}_{SR}} \\abs{\\prescript{}{SR}{\\ip{\\psi _1}{\\psi _2}} _{SR}}^2= \\max_{ \\ket{\\psi _1}_{SR}} \\abs{\\prescript{}{SR}{\\ip{\\psi _1}{\\psi _2}} _{SR}}^2\nwhere the max means the maximum w.r.t. all possible purifications of the state(s).\nProof\nUsed: Schmidt decomposition and Orthogonality relation for unitaries\n"},"Quantum-Information/Entanglement/Bell-states":{"slug":"Quantum-Information/Entanglement/Bell-states","filePath":"../PhysicsVault/Quantum Information/Entanglement/Bell states.md","title":"Bell states","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Vectorization","Quantum-Information/Foundations/Heisenberg-Weyl-operators","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Foundations/Qubits","Quantum-Information/Quantum-Computation/CNOT-gate","Quantum-Information/Quantum-Computation/Hadamard-Gate"],"tags":[],"content":"The notion of Bell states can be defined for any dimension d; specifically, it can be shown that the maximally entangled state \\ket{\\psi}_{AB}\\bra{\\psi} for a pair of qudits is:\n\\ket{\\psi}_{AB}\\bra{\\psi} \\textrm{ maximally entangled}\\Leftrightarrow\\ket{\\psi}_{AB}=\\left(\\mathrm{Id}\\otimes U\\right)\\ket{\\varphi _d}_{AB} = \\frac{1}{\\sqrt{d}}\\mathrm{vec}(U),\n\\ket{\\varphi _d}_{AB} \\equiv \\frac{1}{\\sqrt{d}}\\sum_{j=0}^{d-1}\\ket{j}_A\\ket{j}_B,\nwhere \\mathrm{vec} indicates the vectorization of an operator. The unitaries U are the Heisenberg-Weyl operators W_{a,b}, which are basically a generalization of the Pauli operators to d-dimensional spaces.\n\\ket{\\psi _{a,b}}=\\left(\\mathrm{Id}\\otimes W_{a,b}\\right)\\ket{\\varphi _d}\n\\ket{\\psi _{a,b}}_{AB}=\\frac{1}{\\sqrt{d}} \\sum _{k=0}^{d-1} e^{2\\pi i (k+b)a/d}\\ket{[k+b]_d}_A\\ket{k}_B\nThese states form a basis for the Hilbert space \\mathcal{H}_A\\otimes\\mathcal{H}_B.\nQubit case\nThe Bell basis for Qubits is usually denoted by:\n\\ket{\\Psi ^+ } = \\frac{1}{\\sqrt{2}} \\left(\\ket{00} + \\ket{11}\\right)\n\\ket{\\Psi ^- } = \\frac{1}{\\sqrt{2}} \\left(\\ket{00} - \\ket{11}\\right)\n\\ket{\\Phi ^+ } = \\frac{1}{\\sqrt{2}} \\left(\\ket{10} + \\ket{01}\\right)\n\\ket{\\Phi ^- } = \\frac{1}{\\sqrt{2}} \\left(\\ket{10} - \\ket{01}\\right)\nBell state creation\n\nUsing the CNOT gate and the Hadamard Gate, qubit Bell states can be created, take the state \\ket{\\Psi ^+}_{AB} as an example:\n\\left(CNOT\\circ H_A\\right)\\ket{0}_A\\ket{0}_B = \\ket{\\Psi ^+}_{AB}"},"Quantum-Information/Entanglement/Bell's-theorem":{"slug":"Quantum-Information/Entanglement/Bell's-theorem","filePath":"../PhysicsVault/Quantum Information/Entanglement/Bell's theorem.md","title":"Bell's theorem","links":[],"tags":[],"content":"Bell’s theorem states that hidden variable theories are inconsistent with quantum mechanics, if we exclude the possibility of giving up locality."},"Quantum-Information/Entanglement/CHSH-inequality":{"slug":"Quantum-Information/Entanglement/CHSH-inequality","filePath":"../PhysicsVault/Quantum Information/Entanglement/CHSH inequality.md","title":"CHSH inequality","links":["Quantum-Information/Entanglement/Bell's-theorem","Quantum-Information/Foundations/Composite-systems","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Entanglement/Bell-states"],"tags":[],"content":"The CHSH inequality, named after the authors Clauser, Horne, Shimony, and Holt, is used to experimentally prove Bell’s theorem.\nConsider a bipartite system and 4 binary observables, A,A&#039; for one of the subsystems, and B,B&#039; for the other. Then build the observable\nC\\equiv A(B+B^\\prime)+ A^\\prime (B-B^\\prime)\nSince the outcome of the single observables must be \\pm 1, then:\n\\abs{\\langle C \\rangle} = \\abs{\\langle AB\\rangle +\\langle A^\\prime B\\rangle +\\langle AB^\\prime\\rangle - \\langle A^\\prime B^\\prime\\rangle}\\leq 2\nwhich is the CHSH inequality. Hidden variable theories state that there exists a probability distribution under a variable \\lambda for any observable, so that\n\\langle AB\\rangle= \\sum _{AB}\\int d\\lambda p(\\lambda) AB\\, P(A|\\lambda)P(B|\\lambda)\nQuantum mechanics violates the CHSH inequality: choose the observables:\nA\\mapsto \\hat{\\sigma}_{\\vec{a}} = \\vec{a}\\cdot\\vec{\\sigma}\nB\\mapsto \\hat{\\sigma}_{\\vec{b}} = \\vec{b}\\cdot\\vec{\\sigma}\nwhere the \\vec{\\sigma} are the Pauli operators and \\norm{a}\\leq 1, \\norm{b}\\leq 1.\nNow, if the composite system is in the Bell state\n\\ket{\\Psi ^- } = \\frac{1}{\\sqrt{2}} \\left(\\ket{00} - \\ket{11}\\right)\nthen\n\\bra{\\Psi _-}\\hat{\\sigma}_{\\vec{a}}\\otimes\\hat{\\sigma}_{\\vec{b}}\\ket{\\Psi_-} = -(\\vec{a}\\cdot\\vec{b})\nFinally, we can choose the 4 a,b,a’,b’ vectors to be at a relative angle of \\pi/4 to each other (in that order), if we do so, we find:\n\\langle C\\rangle _{\\psi_-}=2\\sqrt{2}&gt;2"},"Quantum-Information/Entanglement/Choi-state":{"slug":"Quantum-Information/Entanglement/Choi-state","filePath":"../PhysicsVault/Quantum Information/Entanglement/Choi state.md","title":"Choi state","links":["Quantum-Information/Entanglement/Completely-chaotic-state","Quantum-Information/Foundations/Purification","Quantum-Information/Entanglement/Bell-states","Quantum-Information/Open-system-dynamics/Quantum-channels"],"tags":[],"content":"Given the Completely chaotic state in the system A:\n\\bar{\\rho} _A = \\frac{1}{d} \\sum _i \\ket{i}_A\\bra{i}\nwhere d =\\dim\\mathcal{H}_A Consider its Purification on the reference system R\n\\ket{\\Psi}_{AR} =\\frac{1}{\\sqrt{d}}\\sum _i \\ket{i}_A\\ket{i}_R\n\\ket{\\Psi}_{AR} is a Bell state of AR. Then, the Choi state of a quantum channel \\Phi is defined by:\n\\rho _\\Phi \\equiv \\left[\\Phi\\otimes\\chid_R\\right](\\ket{\\Psi}_{AR}\\bra{\\Psi})= \\frac{1}{d}\\sum _{ij}\\Phi \\left(\\ket{i}_A\\bra{j}\\right)\\otimes \\ket{i}_R\\bra{j}"},"Quantum-Information/Entanglement/Completely-chaotic-state":{"slug":"Quantum-Information/Entanglement/Completely-chaotic-state","filePath":"../PhysicsVault/Quantum Information/Entanglement/Completely chaotic state.md","title":"Completely chaotic state","links":["Quantum-Information/Entropies/Von-Neumann-entropy","Quantum-Information/Foundations/Purification","Quantum-Information/Entanglement/Bell-states"],"tags":[],"content":"The completely chaotic state is the state that maximizes the entropy of the system and are usually denoted by a bar \\bar{\\cdot} over the symbol of the operator\n\\bar{\\rho} \\equiv \\frac{1}{\\dim\\mathcal{H}}\\sum _i \\op{i}{i}\nTheir purifications are the maximally entangled states."},"Quantum-Information/Entanglement/Concurrence":{"slug":"Quantum-Information/Entanglement/Concurrence","filePath":"../PhysicsVault/Quantum Information/Entanglement/Concurrence.md","title":"Concurrence","links":["Quantum-Information/Foundations/Qubits","Quantum-Information/Quantum-Computation/Computational-basis"],"tags":[],"content":"Defined for Qubits.\nX_{AB} (\\rho _{AB}) \\equiv\\sqrt{\\sqrt{\\rho_{AB}}\\left(\\sigma_y^{(A)}\\sigma_y^{(B)}\\right)\\rho_{AB} ^*\\left(\\sigma_y^{(A)}\\sigma_y^{(B)}\\right)\\sqrt{\\rho_{AB}}}\nHere, \\rho_{AB} ^* is defined by taking the element wise c.c. (requires fixing the basis - Computational basis).\nEigenvalues of X are ordered \\lambda_1 \\geq\\lambda_2\\geq \\lambda_3\\geq\\lambda _4, then the concurrence is defined as\nC(\\rho_{AB}) \\equiv \\max\\left\\{0,\\lambda_1-\\lambda_2-\\lambda _3-\\lambda _4\\right\\}"},"Quantum-Information/Entanglement/Entangled-states":{"slug":"Quantum-Information/Entanglement/Entangled-states","filePath":"../PhysicsVault/Quantum Information/Entanglement/Entangled states.md","title":"Entangled states","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Convex-combinations","Quantum-Information/Entanglement/Bell-states","Quantum-Information/Entanglement/CHSH-inequality","Quantum-Information/Entanglement/Entanglement-criteria","Quantum-Information/Entropies/Conditional-entropy"],"tags":[],"content":"As seen in Density matrix operators in the subsection regarding joint states, entangled states are all the states which cannot be expressed as Convex combinations of factorized states (separable states):\n\\rho_{AB} \\neq\\sum _i p_i \\rho ^{(i)} _A\\otimes\\tau^{(i)} _B\n\nConvex combinations of entangled states are not necessarily entangled, e.g. the combination of the Bell states with equal probability returns an operator proportional to the identity.\nVolume of separable states is much smaller (but not 0 measure) than that of entangled states\nBell states are the states which maximally violate CHSH inequality, while separable states obey the inequality.\nGenerally, determining whether a state is entangled or not is a NP hard problem, however there are a few criteria which may be useful.\nThe local knowledge of an entangled state carries more information than the knowledge of the corresponding global state. In fact, it can be shown that for a pure state on the bipartite system AB, the state is entangled if and only if the Conditional entropy of B given A is smaller than 0:\n\nS(B|A) &lt;0,\nS(A,B)&lt;S(A)."},"Quantum-Information/Entanglement/Entanglement-cost":{"slug":"Quantum-Information/Entanglement/Entanglement-cost","filePath":"../PhysicsVault/Quantum Information/Entanglement/Entanglement cost.md","title":"Entanglement cost","links":["Quantum-Information/Entanglement/Bell-states","Quantum-Information/Open-system-dynamics/LOCC-protocols","Quantum-Information/Foundations/Density-matrix-operators"],"tags":[],"content":"Alice and Bob share infinite copies of Bell states and can perform LOCC’s; they have to generate a target state \\rho _{AB}^{\\otimes M} using N pairs of these copies. Separable states have 0 cost. Define the rate\nR=\\frac{N}{M}\nwhich vanishes for separable states (A and B don’t need to use any Bell state copy) and maximizes at 1 for Bell states. Then, we define the entanglement cost by taking the limit of the minimum (over LOCC’s) of this rate\nE_C\\left(\\rho _{AB}\\right) =\\lim_{M\\rightarrow\\infty}\\min R\nWe don’t necessarily need to have exact Bell states, but they need to be “close enough”"},"Quantum-Information/Entanglement/Entanglement-criteria":{"slug":"Quantum-Information/Entanglement/Entanglement-criteria","filePath":"../PhysicsVault/Quantum Information/Entanglement/Entanglement criteria.md","title":"Entanglement criteria","links":["Quantum-Information/Entanglement/PPT-criterion","Quantum-Information/Entanglement/Majorization-criterion","Quantum-Information/Entanglement/Entanglement-witness-techinques","Quantum-Information/Open-system-dynamics/Quantum-channel-representations"],"tags":[],"content":"\nPPT criterion\nMajorization criterion\nEntanglement witness techinques\nOther criteria rely on local transformations which are positive but not completely positive (see Quantum channel representations). There is a theorem that states:\nif \\rho_{AB} entangled, then \\exists \\Lambda P but not CP that allows to identify entanglement\n"},"Quantum-Information/Entanglement/Entanglement-distillation":{"slug":"Quantum-Information/Entanglement/Entanglement-distillation","filePath":"../PhysicsVault/Quantum Information/Entanglement/Entanglement distillation.md","title":"Entanglement distillation","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Entanglement/Bell-states","Quantum-Information/Open-system-dynamics/LOCC-protocols","Quantum-Information/Foundations/Partial-transpose","Quantum-Information/Entanglement/PPT-criterion","Quantum-Information/Entanglement/Entanglement-cost","Quantum-Information/Foundations/Qubits"],"tags":[],"content":"Suppose Alice and Bob share N (which will go to infinity) copies of a state \\rho _{AB}. They want to produce (distill) M copies of maximally entangled states.\nR=\\frac{M}{N}\nThis R is the rate of distillation for a fixed LOCC. Now, we take the limit of this rate maximizing over LOCC’s, obtaining the entanglement distillation\nE_D(\\rho_{AB}) =\\lim \\max R\nWe don’t necessarily need to have exact Bell states, but they need to be “close enough”\nFor some entangled states, this functional evaluates to 0 (some entangled states are too weak to produce Bell states, e.g. entangled states whose Partial transpose is positive, see PPT criterion). Distillation is not exactly the inverse of cost, there is some sort of arrow of time.\nE_D(\\rho _{AB}) \\leq E_C(\\rho_{AB})\nFor qb-qb (Qubits) systems, entanglement is always distillable."},"Quantum-Information/Entanglement/Entanglement-measures":{"slug":"Quantum-Information/Entanglement/Entanglement-measures","filePath":"../PhysicsVault/Quantum Information/Entanglement/Entanglement measures.md","title":"Entanglement measures","links":["Quantum-Information/Entanglement/Entangled-states","Quantum-Information/Open-system-dynamics/LOCC-protocols","Quantum-Information/Entanglement/Relative-entropy-of-entanglement","Quantum-Information/Entanglement/Concurrence","Quantum-Information/Entanglement/Entanglement-of-formation","Quantum-Information/Entanglement/Entanglement-cost","Quantum-Information/Entanglement/Entanglement-distillation"],"tags":[],"content":"In order to define a sound entanglement measure E, we need a number of properties:\n\nE:\\sigma\\left(\\mathcal{H}_{AB}\\right)\\mapsto\\mathbb{R}^+\nE(\\rho_{AB}^{sep})=0\nSometimes E(\\rho _{AB} ^{ent})&gt;0\nInvariance under local unitaries E(\\rho _{AB}) = E\\left(U_AV_B\\rho_{AB}U_A^\\dagger V_B^\\dagger\\right). Invariance under global unitaries is impossible because those transformations can generate (and destroy) entanglement\n\\Phi LOCC, then E(\\Phi(\\rho _{AB}))\\leq E(\\rho _{AB})\nWe can find these functionals, namely:\n\n\nRelative entropy of entanglement\nConcurrence\nEntanglement of formation (number of Bell copies necessary to produce a target state)\nEntanglement cost (limit of ratio between Bell copies and copies of a target state to be produced)\nEntanglement distillation (limit of ratio of target number of Bell states and copies of available state)\nDistillation is bigger than cost, meaning that there exists a kind of arrow of time for entanglement\n"},"Quantum-Information/Entanglement/Entanglement-of-formation":{"slug":"Quantum-Information/Entanglement/Entanglement-of-formation","filePath":"../PhysicsVault/Quantum Information/Entanglement/Entanglement of formation.md","title":"Entanglement of formation","links":["Quantum-Information/Entanglement/Bell-states","Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Open-system-dynamics/LOCC-protocols","Quantum-Information/Entanglement/Entanglement-measures","Quantum-Information/Foundations/Ensembles","Quantum-Information/Foundations/Pure-states","Quantum-Information/Foundations/Schmidt-decomposition","Quantum-Information/Entropies/Von-Neumann-entropy"],"tags":[],"content":"The entanglement of formation quantifies the number of maximally entangled states necessary to generate a target state through LOCC protocols.\nThis turns out to be not a precise definition but still a good entanglement measure.\nDefine ensemble so that:\n\\rho _{AB} =\\sum_i p_i \\ket{\\psi_i}_{AB}\\bra{\\psi_i}\nFocus on the Pure states first; find the Schmidt decomposition:\n\\ket{\\psi}_{AB} =\\sum _l \\lambda _l \\ket{\\phi _l}_A\\ket{\\varphi _l}_B\n\\rho _A = \\sum_l \\lambda_l ^2\\op{\\phi_l}{\\phi_l}\nThen, we define the entanglement of formation by:\nE_F(\\rho _{AB})\\equiv\\min _{\\textrm{ensembles}}\\left(\\sum_i p_i S\\left(\\rho _A ^{(i)}\\right)\\right)\n\\rho _A ^{(i)} \\equiv \\tr _B(\\ket{\\psi _i}_{AB}\\bra{\\psi _i})\nwhere S is the Von Neumann entropy."},"Quantum-Information/Entanglement/Entanglement-witness-techinques":{"slug":"Quantum-Information/Entanglement/Entanglement-witness-techinques","filePath":"../PhysicsVault/Quantum Information/Entanglement/Entanglement witness techinques.md","title":"Entanglement witness techinques","links":["Quantum-Information/Entanglement/Entangled-states","Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Entanglement/CHSH-inequality"],"tags":[],"content":"Methods to avoid tomography. Definition of entanglement witness: \\theta observable s.t.:\n\\tr\\left( \\theta \\rho _{AB} ^{sep}\\right)\\geq 0\\quad \\forall \\rho _{AB} ^{sep}\n\\theta must contain negative eigenvalues so that \\exists \\rho _{AB} s.t. \\tr\\left( \\theta \\rho _{AB} \\right)&lt; 0.\nThe condition \\tr(\\theta\\rho) = 0 identifies a hyperplane on the space of bipartite states that divides the space into 2 regions, one of which contains the separable states but also some entangled states, while the other only contains entangled states.\nThere is also the issue of the optimality of the hyperplane (whether it is tangent to separable states or not) + possible rotations in the hyperspace.\nAn example of witness is given by a modified version of the operator defined in CHSH inequality\nC = A\\otimes (B+B^\\prime) +A^\\prime\\otimes(B-B^\\prime)\n\\rho _{AB}^{(sep)} =\\sum_lp_l\\rho ^{(l)} _A \\rho _B ^{(l)}\n\\langle C\\rangle _{sep} =\\sum_l p_l \\left(\\langle A\\rangle _l(\\langle B\\rangle _l+\\langle B^\\prime\\rangle _l) +\\langle A ^\\prime\\rangle _l(\\langle B\\rangle _l-\\langle B^\\prime\\rangle _l)\\right)\\leq 2\n\\langle A\\rangle _l \\equiv \\tr\\left(A\\rho _A ^{(l)}\\right)\nTherefore, we define the witness\n\\theta = 2\\mathrm{Id} - C"},"Quantum-Information/Entanglement/GHZ-states":{"slug":"Quantum-Information/Entanglement/GHZ-states","filePath":"../PhysicsVault/Quantum Information/Entanglement/GHZ states.md","title":"GHZ states","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Entanglement/CHSH-inequality","Quantum-Information/Entanglement/Entangled-states","Quantum-Information/Foundations/Partial-trace"],"tags":[],"content":"Greenberger–Horne–Zeilinger states were proposed to translate the Bell test in multipartite systems\nTake the entangled state\n\\ket{GHZ} = \\frac{\\ket{000}+\\ket{111}}{2}\ntracing over a single subsystem\n\\frac{1}{2}\\left(\\op{00}{00}+\\op{11}{11}\\right)\nwhich is a separable state. Now consider the measurement X_AY_BY_C,\nX_AY_BY_C\\ket{GHZ}=-\\ket{GHZ}\nso the outcome of the associated measurement is \\pm1.\nSwapping the measures X,Y on two subsystems bears the same result. In hidden variable theory, we can associate a quantity m=\\pm1 to each measurement, so that\nm_A^Xm_B^Ym_C^Y=-1\nm_A^Ym_B^Xm_C^Y=-1\nm_A^Ym_B^Ym_C^X=-1\nProblem is that multiplying all these identities together yields\nm_A^Xm_B^Xm_C^X=-1\nGoing back to quantum theory\nX_AX_BX_C\\ket{GHZ}=\\ket{GHZ}\nThis incompatibility is measurable with just 3 measurement"},"Quantum-Information/Entanglement/Impossible-machines/Bell-telephone":{"slug":"Quantum-Information/Entanglement/Impossible-machines/Bell-telephone","filePath":"../PhysicsVault/Quantum Information/Entanglement/Impossible machines/Bell telephone.md","title":"Bell telephone","links":["Quantum-Information/Entanglement/Entangled-states","Quantum-Information/Entanglement/Bell-states","Quantum-Information/Foundations/Qubits","Quantum-Information/Measurements/POVM's","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Entanglement/Popescu-Rohrlich-box","Quantum-Information/Foundations/Density-matrix-operators"],"tags":[],"content":"\nThe idea behind the Bell telephone is to exploit the entanglement in a Bell states to send classical information (bits) without using a classical communication line and without transmission delay, which would violate causality.\nThe protocol would work as follows:\n\nAlice and Bob share a qubit Bell state, say \\ket{\\psi ^+}_{AB}\nAlice can choose to perform a projective measurement on A either on the Z basis or on the X basis (see Pauli operators)\nBob performs the same type of measurement immediately after on B, hoping to read some kind of information\nCall the type of measurement that Alice and Bob perform A,B, while the measurement output is a,b. We don’t have communication if we can verify that, whatever Alice does on her system, Bob won’t notice (see also Popescu-Rohrlich box, where the same condition for non-signaling theories is found):\n\nP(b|A,B) = P(b|A^\\prime, B)\nP(b|A,B) = \\sum_a P(a,b|A,B)\nIn terms of Density matrix operators, the reduced density matrix on Bob’s system will always be the completely chaotic state."},"Quantum-Information/Entanglement/Impossible-machines/Classical-teleportation-machine":{"slug":"Quantum-Information/Entanglement/Impossible-machines/Classical-teleportation-machine","filePath":"../PhysicsVault/Quantum Information/Entanglement/Impossible machines/Classical teleportation machine.md","title":"Classical teleportation machine","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Entanglement/Impossible-machines/Quantum-cloner","Quantum-Information/Measurements/Quantum-state-tomography"],"tags":[],"content":"We want to send a quantum state using a single copy of it from Alice to Bob; schematically:\n\nYou could build a Quantum cloner out of it. It is possible to prove that quantum cloners and classical teleportation are the same\nClassical teleportation → Quantum cloner\n\nQuantum cloner → Classical teleportation\nWe need to employ Quantum state tomography.\n"},"Quantum-Information/Entanglement/Impossible-machines/Joint-measurement-of-incompatible-observables":{"slug":"Quantum-Information/Entanglement/Impossible-machines/Joint-measurement-of-incompatible-observables","filePath":"../PhysicsVault/Quantum Information/Entanglement/Impossible machines/Joint measurement of incompatible observables.md","title":"Joint measurement of incompatible observables","links":["Quantum-Information/Entanglement/Impossible-machines/Bell-telephone","Quantum-Information/Entanglement/CHSH-inequality"],"tags":[],"content":"\nIncompatible observables means [A,B]\\neq 0.\nThe goal of this protocol is to find:\nP_\\psi(a,b|A\\&amp;B)\nProblems arise from some conditions (here, \\overset{\\cdot}{=} signifies imposing a condition):\n\nMarginal on measures on A reproduces measure on A\n\nP_\\psi(a|A\\&amp;B)=\\sum_bP_\\psi(a,b|A\\&amp;B)\\overset{\\cdot}{=}P_\\psi(a|A)\n\nSame for B\n\nP_\\psi(b|A\\&amp;B)=\\sum_aP_\\psi(a,b|A\\&amp;B)\\overset{\\cdot}{=}P_\\psi(b|B)\nThese two conditions taken together are incompatible. If such a machine is possible, then so is the Bell telephone ([X,Z]\\neq 0).\nProof through Bell test\nConsider the same setting of measures for the CHSH inequality, with the further assumption that Bob has a machine for joint measurement of B,B’ and that [B,B^\\prime]\\neq 0. Message is encoded in the type measurement chosen by Alice. On Bob’s side, the communication protocol dictates:\n\\left\\{\\begin{array}{l}\nb=b^\\prime \\Rightarrow A\\\\\nb=-b^\\prime \\Rightarrow A^\\prime\n\\end{array}\\right.\nCompute the probability of success of the protocol:\n\nP(A) = P(A&#039;) = \\frac{1}{2}\nP(b=b&#039;|A) = \\sum_{a,b,b^\\prime} P(a,b,b^\\prime|A,B\\&amp;B^\\prime)\\frac{\\abs{b+b^\\prime}\\abs{a}}{2}\n\\abs{b+b^\\prime}=2 if b=b&#039;, 0 otherwise.\nP(b=-b&#039;|A&#039;) = \\sum_{a&#039;,b,b^\\prime} P(a,b,b^\\prime|A&#039;,B\\&amp;B^\\prime)\\frac{\\abs{b&#039;-b}\\abs{a&#039;}}{2}\nP_{succ} =\\frac{1}{2}\\sum_{a,b,b^\\prime} P(a,b,b^\\prime|A,B \\&amp; B^\\prime)\\frac{\\abs{b+b^\\prime}\\abs{a}}{2}+\\frac{1}{2}\\sum_{a&#039;,b,b^\\prime}P(a,b,b^\\prime|A,B\\&amp;B^\\prime)\\frac{\\abs{b-b^\\prime}\\abs{a&#039;}}{2}\nWe only need to prove P_{succ}\\geq \\frac{1}{2}. If this is the case, then we could build a Bell telephone, which we know to be impossible. Removing abs val on a,a^\\prime creates lower bound. Carry out the sum employing marginal of joint incompatible measurement machine (conditions above). One of the terms is\n\\sum_{a,b,b^\\prime} P(a,b,b^\\prime|A,B\\&amp;B^\\prime)\\frac{(b+b&#039;)a}{2} = \\frac{1}{2}\\sum_{ab}P(a,b|A,B)ab+\\frac{1}{2}\\sum_{ab&#039;}P(a,b^\\prime|A,B^\\prime)ab^\\prime\nDo the same for the other.\nNow, notice that we have a sum of expectation values, for example:\n\\sum_{ab}P(a,b|A,B)ab = \\langle AB\\rangle\nSo that\nP_{succ}\\geq\\frac{1}{4}\\left(\\langle AB\\rangle+\\langle AB^\\prime\\rangle+\\langle A^\\prime B\\rangle-\\langle A^\\prime B^\\prime\\rangle\\right)=\\langle C\\rangle/4\nTherefore:\nP_{succ}\\geq\\frac{\\sqrt{2}}{2}&gt; \\frac{1}{2}"},"Quantum-Information/Entanglement/Impossible-machines/Quantum-cloner":{"slug":"Quantum-Information/Entanglement/Impossible-machines/Quantum-cloner","filePath":"../PhysicsVault/Quantum Information/Entanglement/Impossible machines/Quantum cloner.md","title":"Quantum cloner","links":["Quantum-Information/Entanglement/Impossible-machines/Bell-telephone","Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Ensembles","Quantum-Information/Open-system-dynamics/Quantum-channel-representations"],"tags":[],"content":"\nWe show that, were a quantum cloner possible, then so must be the Bell telephone.\nIn a Bell telephone setting, suppose Bob has a quantum cloner; then, after a measurement from Alice, he copies his state n times, so that he has n copies of the same state ⇒ He can decode alice’s choice of measurement, as he would have one of the following Ensembles.\n\\mathcal{E} = \\left\\{\\frac{1}{2};\\ket{0}^{\\otimes n},\\ket{1}^{\\otimes n}\\right\\}\n\\mathcal{E} = \\left\\{\\frac{1}{2};\\ket{+}^{\\otimes n},\\ket{-}^{\\otimes n}\\right\\}\nThese two configurations are distinguishable.\nDirect proof of impossibility\nThe map representing a quantum cloner can be written as\n\\Phi _{cloner} (\\op{\\psi}{\\psi}\\,\\op{0}{0}) = \\op{\\psi}{\\psi}\\,\\op{\\psi}{\\psi}\nIn Stinespring representation:\n\\Phi _{cloner} (\\op{\\psi}{\\psi}\\,\\op{0}{0}) = \\tr_E \\left(U_{SE} (\\op{\\psi}{\\psi}\\,\\op{0}{0})\\,\\ket{0}_E\\bra{0})U_{SE}^\\dagger\\right)\nEverything is pure, so the problem is equivalent to:\nU_{SE} \\ket{\\psi}_S\\ket{0}_S\\ket{0}_E = \\ket{\\psi}_S\\ket{\\psi}_S\\ket{\\chi_\\psi}_E \\quad\\forall\\psi\nThis is impossible though, in fact we can take the inner product\n\\ip{\\psi}{\\phi} =\\abs{\\ip{\\psi}{\\phi}}^2\\ip{\\chi_\\psi}{\\chi_\\phi}\nThis can be satisfied for orthogonal states (classical copier), otherwise it only works on a single vector. A quantum cloner does not work even for just two non-orthogonal vectors, which is exactly the setting for bell telephones."},"Quantum-Information/Entanglement/Impossible-machines/Universal-NOT-gate":{"slug":"Quantum-Information/Entanglement/Impossible-machines/Universal-NOT-gate","filePath":"../PhysicsVault/Quantum Information/Entanglement/Impossible machines/Universal NOT gate.md","title":"Universal NOT gate","links":["Quantum-Information/Foundations/Qubits","Quantum-Information/Entanglement/Impossible-machines/Quantum-cloner","Quantum-Information/Notable-channels/Depolarizing-channel"],"tags":[],"content":"Universal NOT means flipping any state on the Bloch sphere:\n\\ket{\\psi}\\overset{UNOT}{\\mapsto}\\ket{\\psi ^\\perp}\\quad\\forall \\psi.\nIf this was possible ⇒ Quantum cloner\nApproximate UNOT\nApproximate UNOT means that:\n\\forall\\epsilon, \\exists ? \\Phi \\textrm{ LCPT s.t.} \\quad F\\left(\\Phi(\\op{\\psi}{\\psi}), \\op{\\psi^\\perp}{\\psi^\\perp}\\right)\\geq 1-\\epsilon \\quad\\forall\\psi \nThe Depolarizing channel:\n\\Phi _p (\\rho) =p\\rho +(1-p)\\mathrm{Id}/2\ncan be defined as a map even for some negative p. What happens then is that the output state is kind of a UNOT as it lies on the opposite side of the line in the Bloch sphere, however the line is shorter (not pure)."},"Quantum-Information/Entanglement/Majorization-criterion":{"slug":"Quantum-Information/Entanglement/Majorization-criterion","filePath":"../PhysicsVault/Quantum Information/Entanglement/Majorization criterion.md","title":"Majorization criterion","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Entanglement/Entangled-states","pipeline-inequalities"],"tags":[],"content":"Given two probability distributions p_j,p^\\prime _j, j=0,...,d-1, we want to know which one is the noisiest.\np_j ^{(\\downarrow)} is the reordered distribution with descending prob weight p_j ^{(\\downarrow)}\\geq p_{j+1} ^{(\\downarrow)}.\nThen, we define the majorization:\n\\sum _{j=1} ^k p_j ^{(\\downarrow)}\\geq\\sum _{j=1} ^k p_j ^{\\prime(\\downarrow)}\\quad\\forall k\\Rightarrow \\{p_k\\}\\succcurlyeq \\{p^\\prime_k\\}\nAnd the majorization theorem:\nif \\{p_k\\}\\succcurlyeq \\{p^\\prime_k\\} there exists bistochastic distribution that casts \\{p_k\\} into \\{p^\\prime_k\\}.\nThis can be transposed into the quantum case by considering the spectra of bipartite states\n\\rho _{AB} =\\sum_j \\lambda _j \\op{\\psi_j}{\\psi_j}\n\\rho _A =\\tr _B\\rho _{AB} =\\sum _k q_k\\op{\\phi_k}{\\phi_k}\nI can promote the q distribution into the support of the \\lambda distribution by adding “0” entries. Then, the majorization criterion states that\n\\rho _{AB} \\textrm{ is separable} \\Rightarrow\\{\\lambda _j\\}\\preccurlyeq \\{q_k\\}\n\\rho _{AB} \\textrm{ is separable} \\Rightarrow\\rho _{AB} \\preccurlyeq \\rho _{A/B} \nwhich implies that for separable states, the global state is more noisy than the local ones. For Entangled states , this could be reversed, which does not happen in classical mechanics (entangled states are sometimes more ordered globally than locally).\nOrdering also translates into pipeline inequalities."},"Quantum-Information/Entanglement/PPT-criterion":{"slug":"Quantum-Information/Entanglement/PPT-criterion","filePath":"../PhysicsVault/Quantum Information/Entanglement/PPT criterion.md","title":"PPT criterion","links":["Quantum-Information/Foundations/Partial-transpose"],"tags":[],"content":"The partial transpose criterion is based upon the Partial transpose operation. When the partial transpose is applied to separable states, it does not cause any problem as it maps separable states into separable states.\nWhen the partial transpose is applied to entangled states, it could happen that the result is non positive.\n\\rho _{AB} ^{T_A} \\not\\geq 0\\Rightarrow \\rho _{AB} ^{T_A} \\textrm{ is entangled}\nNot the other way around (unless we are considering qubit-qubit and qutrit-qubit cases)."},"Quantum-Information/Entanglement/Popescu-Rohrlich-box":{"slug":"Quantum-Information/Entanglement/Popescu-Rohrlich-box","filePath":"../PhysicsVault/Quantum Information/Entanglement/Popescu-Rohrlich box.md","title":"Popescu-Rohrlich box","links":["Quantum-Information/Entanglement/Tsirelson's-bound"],"tags":[],"content":"\nThe PR box violates the Tsirelson’s bound without communication between parties, how does it work?\nx,y are selected by Alice and Bob to select the type of measurement to perform on the box (A,A’ …), while a,b are the measurement outcomes.\nJoint conditional prob distribution:\nP(a,b|x,y) = \\left\\{\\begin{array}{l} 1/2 \\quad a\\mathrm{XOR}b = x\\mathrm{AND} y\\\\ 0 \\quad otherwise\\end{array}\\right.\nwhich leads to a truth table:\n\nIt might look like that Alice and Bob are actually coordinating, and that communication might be hidden somewhere, is that actually the case?\nBeing non signaling means that whatever Alice does, Bob cannot detect that action and viceversa ⇒ marginal probability distribution on Alice’s side\nP(a|x,y) = \\sum_b P(a,b|x,y)\nif theory is non signaling\nP(a|x,y) = P(a|x, y^\\prime)\\quad \\forall y,y^\\prime\nthis is exactly what happens.\nIn the real world there must exist a hidden communication line for the box to work, but once it is built, from Alice and Bob’s perspective there is no communication.\nThe pr box has \\langle C\\rangle = 4"},"Quantum-Information/Entanglement/Relative-entropy-of-entanglement":{"slug":"Quantum-Information/Entanglement/Relative-entropy-of-entanglement","filePath":"../PhysicsVault/Quantum Information/Entanglement/Relative entropy of entanglement.md","title":"Relative entropy of entanglement","links":["Quantum-Information/Distances/Trace-Distance"],"tags":[],"content":"It is a geometric measure of entanglement, represented by the distance between the state and the separable states:\nE(\\rho_{AB}) \\equiv \\min _{\\rho _{AB}^{sep}}D\\left(\\rho_{AB},\\rho_{AB}^{sep}\\right)"},"Quantum-Information/Entanglement/Tsirelson's-bound":{"slug":"Quantum-Information/Entanglement/Tsirelson's-bound","filePath":"../PhysicsVault/Quantum Information/Entanglement/Tsirelson's bound.md","title":"Tsirelson's bound","links":["Quantum-Information/Entanglement/CHSH-inequality","Quantum-Information/Foundations/Operator-norm","Quantum-Information/Entanglement/Bell-states","Quantum-Information/Entanglement/Popescu-Rohrlich-box"],"tags":[],"content":"Tsirelson’s bound dictates a constraint on the correlations measured with the CHSH inequality. Using the same notation:\nC^2 = 4\\mathrm{Id}+[A,A^\\prime]\\otimes[B,B^\\prime]\nThen we take the Operator norm and employ the triangular inequality\n\\norm{C^2}_\\infty\\leq4+\\norm{[A,A^\\prime]}_\\infty\\norm{[B,B^\\prime]}_\\infty\nAll the A,A’,B,B’ have norm 1. We can employ this and apply the triangular inequality to the norm of the commutators.\n\\norm{[A,A^\\prime]}_\\infty\\leq \\norm{AA^\\prime}_\\infty+\\norm{A^\\prime A}_\\infty\\leq 2\\norm{A}_\\infty\\norm{A^\\prime}_\\infty=2\n\\norm{C^2}_\\infty\\leq 8\n\\norm{C}_\\infty=\\sqrt{\\norm{C^2}_\\infty} \\leq 2\\sqrt{2}\nBell states are the states that saturate this bound, as seen in CHSH inequality.\nTsirelson’s bound violations\nIn principle, a theory which is not quantum mechanics could permit \\langle C\\rangle =4. Can we imagine such theories?\nYes, e.g. Alice and Bob coordinate their measures. To do so you need some kind of communication between A and B.\nThere are also theories that do not allow communication between parties yet still violate Tsirelson’s bound, e.g. Popescu-Rohrlich box"},"Quantum-Information/Entanglement/Werner-states":{"slug":"Quantum-Information/Entanglement/Werner-states","filePath":"../PhysicsVault/Quantum Information/Entanglement/Werner states.md","title":"Werner states","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Qubits","Quantum-Information/Entanglement/PPT-criterion","Quantum-Information/Entanglement/Entanglement-measures","Quantum-Information/Open-system-dynamics/LOCC-protocols"],"tags":[],"content":"Werner states are qubit-qubit states defined by:\n\\rho _{AB} (p) = p\\op{\\psi _-}{\\psi _-} +(1-p) \\mathbb{1}/4\nso, \\exists p_0: Werner state is on the border that divides separable and entangled states. This p_0 can be found through PPT (qubit-qubit case is 1/3)\nThere exist Entanglement measures which are monotonous non increasing under LOCC transformation, then if a state is not a Werner state it can be transformed into one following a LOCC map; if the resulting Werner state is entangled, then so must be the original state."},"Quantum-Information/Entropies/Conditional-entropy":{"slug":"Quantum-Information/Entropies/Conditional-entropy","filePath":"../PhysicsVault/Quantum Information/Entropies/Conditional entropy.md","title":"Conditional entropy","links":[],"tags":[],"content":"placeholder\nS(A|B) \\equiv S(A,B) - S(B)"},"Quantum-Information/Entropies/Shannon-entropy":{"slug":"Quantum-Information/Entropies/Shannon-entropy","filePath":"../PhysicsVault/Quantum Information/Entropies/Shannon entropy.md","title":"Shannon entropy","links":[],"tags":[],"content":"Given a probability distribution \\{\\lambda\\}, we can define the Shannon entropy\nH(\\lambda_k) = -\\sum _i \\lambda _i \\logbit \\lambda _i\nDecision tree splits\nIn the context of decision trees, given the node t which splits into child nodes j‘s,\nH(t) = -\\sum _j p(j|t) \\logbit p(j|t)\nwe can also define the information gain\n\\mathrm{GAIN}_{split} (t) \\equiv H(t) - \\sum _j\\frac{n_j}{n_t}H(j)\nwhere n_k is the number of records at node k.\nA decision tree based on the minimization of entropy tends to prefer a large number of partitions. Solution: consider only binary split or modify the information gain:\n\\mathrm{GainRatio}_{split}(t) \\equiv \\frac{\\mathrm{GAIN}_{split}(t)}{\\mathrm{SplitInfo}(t)}\n\\mathrm{SplitInfo} (t)\\equiv- \\sum _j \\frac{n_j}{n_t}\\logbit\\frac{n_j}{n_t}"},"Quantum-Information/Entropies/Von-Neumann-entropy":{"slug":"Quantum-Information/Entropies/Von-Neumann-entropy","filePath":"../PhysicsVault/Quantum Information/Entropies/Von Neumann entropy.md","title":"Von Neumann entropy","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Entropies/Shannon-entropy"],"tags":[],"content":"Given a state \\rho, we can define its Von Neumann entropy:\nS(\\rho) \\equiv -\\tr(\\rho\\logbit\\rho)\nIf we find the spectral decomposition of \\rho, so that \\lambda_k are its eigenvalues, the Von Neumann entropy reduces to the Shannon entropy for the probability distribution \\{\\lambda\\}:\nS(\\rho) = H(\\lambda_k) = -\\sum _i \\lambda _i \\logbit \\lambda _i"},"Quantum-Information/Foundations/Closed-systems":{"slug":"Quantum-Information/Foundations/Closed-systems","filePath":"../PhysicsVault/Quantum Information/Foundations/Closed systems.md","title":"Closed systems","links":["Schrödinger's-equation"],"tags":[],"content":"Closed systems are physical systems that evolve following Schrödinger’s equation, meaning that evolutions are unitary and invertible. Physically, this means that the system has no interactions with an external system."},"Quantum-Information/Foundations/Composite-systems":{"slug":"Quantum-Information/Foundations/Composite-systems","filePath":"../PhysicsVault/Quantum Information/Foundations/Composite systems.md","title":"Composite systems","links":[],"tags":[],"content":"Given two Hilbert spaces \\mathcal{H}_A and \\mathcal{H}_B, a composite system can be constructed out of the two:\n\\mathcal{H}_{AB} = \\mathcal{H}_A\\otimes\\mathcal{H}_B\nand vectors in \\mathcal{H}_{AB} assume the form\n\\ket{\\psi}_{AB} = \\sum_{ij} \\alpha _{ij}\\ket{i}_A\\otimes\\ket{\\varphi _j}_B\nwhere \\{\\ket{i}_A\\}_i and  \\{\\ket{\\varphi _j}_B\\}_j are bases for \\mathcal{H}_A and \\mathcal{H}_B respectively."},"Quantum-Information/Foundations/Convex-combinations":{"slug":"Quantum-Information/Foundations/Convex-combinations","filePath":"../PhysicsVault/Quantum Information/Foundations/Convex combinations.md","title":"Convex combinations","links":[],"tags":[],"content":"Given elements \\vec{v}_i of a vector space, we can build the convex combination of the \\vec{v}_i from a probability distribution \\{\\lambda _i\\}_i:\n\\sum_i \\lambda_i \\vec{v}_i"},"Quantum-Information/Foundations/Density-matrix-operators":{"slug":"Quantum-Information/Foundations/Density-matrix-operators","filePath":"../PhysicsVault/Quantum Information/Foundations/Density matrix operators.md","title":"Density matrix operators","links":["Quantum-Information/Foundations/Pure-states","Quantum-Information/Foundations/Open-systems","Quantum-Information/Foundations/Ensembles","Quantum-Information/Foundations/Convex-combinations","Quantum-Information/Foundations/Partial-trace","Quantum-Information/Foundations/Composite-systems","Quantum-Information/Foundations/Schmidt-decomposition"],"tags":[],"content":"Density matrix operators are a generalization of Pure states, where the presence of noise (or external perturbation) is admitted in the system, see Open systems. A generic density matrix operator \\rho needs to satisfy the following properties:\n\n\\rho is a hermitian operator:\n\n\\rho = \\rho ^\\dagger\n\nIn order to satisfy the probabilistic interpretation of quantum mechanics:\n\n\\tr \\rho = 1\n\nGenerally\n\\tr\\rho ^2\\leq 1\nwhen the inequality is saturated, the state is said to be pure, otherwise it is said to be mixed. Mixed state are associated with the presence of classical noise in the system (see Ensembles).\n\\rho is positive semidefinite\n\\rho\\geq 0\nwhich means it can always be cast in the form\n\\rho = \\sum_k p_k\\op{\\psi_k}{\\psi _k}\nfrom this form (called spectral decomposition), it is clear that any mixed state can be expressed as a convex combination of pure states; this has an immediate connection to Ensembles.\n\nSpace of density operators\n\\sigma(\\mathcal{H}) = \\left\\{\\rho: \\rho\\textrm{ is a density matrix operator}\\right\\}\n\\sigma(\\mathcal{H}) is a convex space, meaning that it is closed under Convex combinations:\n\\sum _j p_j\\rho _j\\in \\sigma(\\mathcal{H})\nThe border (vertices and curve lines) of \\sigma(\\mathcal{H}) represent pure states.\nOpen systems\nConsider an open system \\mathcal{H}_S interacting with an environment \\mathcal{H}_E; the state of the total system is\n\\rho _{SE} \\in \\sigma\\left(\\mathcal{H}_{SE}\\right)\nit is possible to recover the information of the state of the system S from \\rho _{SE} by performing a Partial trace operation:\n\\rho _S=\\tr _E \\rho _{SE}\nthis operator is called reduced density matrix.\nTypes of joint states\nStates in a composite system \\mathcal{H}_{AB} = \\mathcal{H_A}\\otimes\\mathcal{H}_B, called joint states, can be categorized as follows:\n\nFactorized states, which can be cast in the form\n\\rho_{AB} = \\rho _A\\otimes\\tau _B\nwhere \\rho _A\\in \\sigma(\\mathcal{H}_A) and \\tau _B\\in \\sigma(\\mathcal{H}_B).\nSeparable states, which are Convex combinations of factorized states:\n\\rho_{AB} =\\sum _i p_i \\rho ^{(i)} _A\\otimes\\tau^{(i)} _B\nwhere \\rho _A^{(i)}\\in \\sigma(\\mathcal{H}_A) and \\tau _B^{(i)}\\in \\sigma(\\mathcal{H}_B)\nEntangled states (or non separable), which cannot be expressed as convex combinations of factorized states. Entangled state represent states whose correlations between the reduced density matrices of the composite system are not just classical (as is the case for separable states).\n\nPure states\nPure composite states are either factorized\n\\ket{\\psi} _{AB} = \\ket{\\psi}_A\\ket{\\phi}_B\nor entangled (not factorized). These two cases can be distinguished through the Schmidt decomposition.\nThe convex combination of factorized states only works in the density matrix operator framework."},"Quantum-Information/Foundations/Ensembles":{"slug":"Quantum-Information/Foundations/Ensembles","filePath":"../PhysicsVault/Quantum Information/Foundations/Ensembles.md","title":"Ensembles","links":["Quantum-Information/Foundations/Pure-states","Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Orthogonality-relation-for-unitaries","Quantum-Information/Foundations/Purification"],"tags":[],"content":"State ensembles are statistical collections of pure states. It is useful to define them through a real-world scenario: suppose that we have a machine capable of preparing pure states (state preparation device), however the machine is not perfect, leading to the creation of a set of states \\{\\ket{\\psi}_i\\}_i, whose rate follows a probability distribution p_i. Then, the ensemble is given by this set of states and the associated probability distribution.\n\\varepsilon\\equiv \\left\\{\\ket{\\psi _i}\\in\\mathcal{H}, \\quad p_i\\textrm{ probabilty distribution}\\right\\}_i\nEnsembles and density operators\nMultiple ensembles can be associated with the same density operator, so that they are functionally (i.e. from a measurement perspective) the same.\nHow are different ensembles with the same density operator linked together?\nConsider two ensembles\n\\varepsilon = \\left\\{\\ket{\\psi _i},p_i\\right\\}_i\\qquad\\varepsilon &#039; = \\left\\{\\ket{\\phi _i},q_i\\right\\}_i\nGenerally, the indices can span different ranges, however those can be brought to the same range by adding states with null weight.\nDenote the equivalence relation between ensembles with \\varepsilon \\sim\\varepsilon &#039;, meaning that they can be described by the same density operator \\rho, then\n\\varepsilon \\sim\\varepsilon &#039;\\Leftrightarrow \\exists \\,\\mathcal{U} \\textrm{ unitary}:\\sqrt{p_i}\\ket{\\psi_i}=\\mathcal{U}_{ij}\\sqrt{q_j}\\ket{\\phi_j}\nwhere \\mathcal{U}_{ij} are the matrix elements of the unitary \\mathcal{U}.\nProof\n\\Leftarrow\nRemember the Orthogonality relation for unitaries:\n\\sum _l \\mathcal{U}_{il}\\mathcal{U}^*_{jl} = \\delta _{ij}\n\\sum _l \\mathcal{U}^*_{li}\\mathcal{U}_{lj} = \\delta _{ij}\nConstruct the density operators associated with the two ensembles\n\\rho = \\sum_i p_i\\op{\\psi_i}{\\psi _i}\n\\rho &#039; = \\sum_i q_i\\op{\\phi_i}{\\phi _i}\nUsing the orthogonality relations and\n\\sqrt{p_i}\\ket{\\psi_i}=\\mathcal{U}_{ij}\\sqrt{q_j}\\ket{\\phi_j}\ndirect computation shows that \\rho = \\rho ^\\prime\n\\Rightarrow\nConsider two purifications of \\rho, (whose system we denote with S, so \\rho \\rightarrow \\rho _S), \\ket{\\psi}_{SR},\\ket{\\psi &#039;}_{SR}\n\\ket{\\psi}_{SR} \\equiv \\sum _i \\sqrt{p_i}\\ket{\\psi_i}_S\\ket{i}_R\n\\ket{\\psi &#039;}_{SR} \\equiv \\sum _i \\sqrt{q_i}\\ket{\\phi_i}_S\\ket{i}_R\nDifferent purifications are linked by a local unitary U_R:\n\\ket{\\psi &#039;}_{SR} = \\left(\\id_S\\otimes U_R\\right)\\ket{\\psi}_{SR}\nBy computing \\prescript{}{R}{\\ip{i}{\\psi&#039;}}_{SR}  on both sides of the relation above, we arrive at\n\\sqrt{p_i}\\ket{\\psi_i}=\\mathcal{U}_{ij}\\sqrt{q_j}\\ket{\\phi_j}\nwhere we define \\mathcal{U}_{ij} \\equiv \\matel{i}{U_R}{j}."},"Quantum-Information/Foundations/Euler-rotations":{"slug":"Quantum-Information/Foundations/Euler-rotations","filePath":"../PhysicsVault/Quantum Information/Foundations/Euler rotations.md","title":"Euler rotations","links":[],"tags":[],"content":"Given a rotation of \\theta around a 3-dimensional axis \\hat{n}, \\exists\\,\\alpha_1,\\alpha_2,\\alpha_3 such that:\nU_{\\hat{n}} (\\theta) = U_{\\hat{z}}(\\alpha_1)U_{\\hat{x}}(\\alpha_2)U_{\\hat{z}}(\\alpha _3)\nThere exists a generalized version of this theorem, relying on rotations around two arbitrary, non necessarily orthogonal, axes. The number of rotations required depends on “how orthogonal” the two axes are.\nGeneralized Euler rotations\n\nUsing:\nU^\\dagger_{\\hat{n}}(\\theta)\\sigma _i U_{\\hat{n}}(\\theta)= \\sum_j\\left(R(\\theta)_{\\hat{n}}\\right)_{ij}\\sigma_j\nWe find the action of a rotation unitary upon another rotation unitary:\n\\begin{split}U^\\dagger_{\\hat{n}}(\\theta)U_{\\hat{m}}(\\phi) U_{\\hat{n}}(\\theta)&amp; = \\exp\\left[-\\frac{i}{2}\\sum_i m_iU^\\dagger_{\\hat{n}}(\\theta)\\sigma_i U_{\\hat{n}}(\\theta) \\phi\\right]\\\\&amp;= \\exp\\left[-\\frac{i}{2}\\sum_{ij} m_i\\left(R(\\theta)_{\\hat{n}}\\right)_{ij}\\sigma_j \\phi\\right]\\\\ &amp;= U_{R_{\\hat{n}}(-\\theta){\\hat{m}}}(\\phi)\\end{split}\nBasically, given the possibility of performing rotations around two non-orthogonal vectors, rotations around all the vectors obtained by rotating the original vectors around one another are also possible. Using this trick, it is possible to generate at least a pair of orthogonal vectors, from which we return to the original Euler rotations.\nLemma for unitaries\nStatement\nWe can prove that, given a unitary U\\in SU(2):\nU = (\\textrm{global phase}) AXBXC\nwhere A,B,C are unitaries such that ABC=\\mathrm{Id}.\nProof\nStarting from Euler’ theorem we have:\nU = (\\textrm{global phase}) U_{\\hat{z}}(\\alpha)U_{\\hat{y}}(\\beta)U_{\\hat{z}}(\\delta)\nUsing XYX = -Y:\nXU_{\\hat{y}}(\\beta)X = U_{\\hat{y}}(-\\beta)\nsame thing for Z:\nXU_{\\hat{z}}(\\beta)X = U_{\\hat{z}}(-\\beta)\nso that:\nU = (\\textrm{global phase}) U_{\\hat{z}}(\\alpha)U_{\\hat{y}}(\\beta/2)XU_{\\hat{y}}(-\\beta/2) XU_{\\hat{z}}(\\delta)\nU = (\\textrm{global phase}) U_{\\hat{z}}(\\alpha)U_{\\hat{y}}(\\beta/2)XU_{\\hat{y}}(-\\beta/2) XXU_{\\hat{z}}\\left(-\\frac{\\delta+\\alpha}{2}\\right)XU_{\\hat{z}}\\left(\\frac{\\delta-\\alpha}{2}\\right)\nU = (\\textrm{global phase}) U_{\\hat{z}}(\\alpha)U_{\\hat{y}}(\\beta/2)XU_{\\hat{y}}(-\\beta/2) U_{\\hat{z}}\\left(-\\frac{\\delta+\\alpha}{2}\\right)XU_{\\hat{z}}\\left(\\frac{\\delta-\\alpha}{2}\\right)\nNow we can claim\nA \\equiv U_{\\hat{z}}(\\alpha)U_{\\hat{y}}(\\beta/2)\nB\\equiv U_{\\hat{y}}(-\\beta/2) U_{\\hat{z}}\\left(-\\frac{\\delta+\\alpha}{2}\\right)\nC \\equiv U_{\\hat{z}}\\left(\\frac{\\delta-\\alpha}{2}\\right)\nand\nABC = \\mathrm{Id}"},"Quantum-Information/Foundations/Heisenberg-Weyl-operators":{"slug":"Quantum-Information/Foundations/Heisenberg-Weyl-operators","filePath":"../PhysicsVault/Quantum Information/Foundations/Heisenberg-Weyl operators.md","title":"Heisenberg-Weyl operators","links":["Quantum-Information/Foundations/Pauli-operators"],"tags":[],"content":"The Heisenberg-Weyl operators W_{a,b} are basically a generalization of the Pauli operators for d-dimensional spaces:\nZ(a) \\equiv \\sum_{k=0} ^{d-1} e^{2\\pi i\\frac{ka}{d}}\\op{k}{k},\nX(b) \\equiv \\sum_{k=0}^{d-1} \\op{[k+b]_d}{k},\nW_{a,b} \\equiv Z(a) X(b),\nW_{a,b} = \\sum_{k=0}^{d-1} e^{2\\pi i (k+b)a/d}\\op{[k+b]_d}{k}\nWhere a,b\\in\\left\\{0,...,d-1\\right\\}.\nSome of their properties:\nW_{a,b} ^\\dagger = e^{-\\frac{2\\pi i}{d}ab}W_{-a,-b}\nW_{a_1,b_1} W_{a_2,b_2} =e^{-2\\pi i \\frac{b_1 a_2}{d}} W_{a_1+a_2,b_1+b_2}\n\\tr\\left(W^\\dagger_{a_1,b_1} W_{a_2,b_2}\\right) = d \\delta_{a_1 a_2}\\delta _{b_1b_2}"},"Quantum-Information/Foundations/Open-systems":{"slug":"Quantum-Information/Foundations/Open-systems","filePath":"../PhysicsVault/Quantum Information/Foundations/Open systems.md","title":"Open systems","links":["Quantum-Information/Foundations/Closed-systems","Quantum-Information/Foundations/Purification"],"tags":[],"content":"Open quantum systems describe physical systems that present interactions with an external system (conventionally called environment) over which we assume to have no control (can’t perform measurements etc.). Let us call the Hilbert space of the system that we control \\mathcal{H}_S and \\mathcal{H}_E the Hilbert space associated to the environment; then, the composite (total) system is denoted by\n\\mathcal{H}_{SE} = \\mathcal{H} _S\\otimes\\mathcal{H}_E\nWe can always assume \\mathcal{H}_{SE} to be a closed system, so that its states evolve following unitary transformations.\nWhen we discard the system of the environment, its action lingers on the system \\mathcal{H}_S in the form of noise ⇒ classical noise is the result of the interaction with the system with an external inaccessible environment (see Purification)."},"Quantum-Information/Foundations/Operator-norm":{"slug":"Quantum-Information/Foundations/Operator-norm","filePath":"../PhysicsVault/Quantum Information/Foundations/Operator norm.md","title":"Operator norm","links":[],"tags":[],"content":"Given an operator\n\\theta \\in\\mathcal{L}(\\mathcal{H})\nthe operator norm is defined by\n\\norm{\\theta}_\\infty \\equiv \\sup _{\\norm{\\ket{v}}=1}\\norm{\\theta\\ket{v}}\nwhere \\ket{v} is a vector of the Hilbert space"},"Quantum-Information/Foundations/Orthogonality-relation-for-unitaries":{"slug":"Quantum-Information/Foundations/Orthogonality-relation-for-unitaries","filePath":"../PhysicsVault/Quantum Information/Foundations/Orthogonality relation for unitaries.md","title":"Orthogonality relation for unitaries","links":[],"tags":[],"content":"By definition, unitary matrices U satisfy\nUU^\\dagger = U^\\dagger U = \\id\nIn quantum information, many computations are carried out using matrix elements\nU = \\sum _{ij} U_{ij}\\op{i}{j}\nThe orthogonality relations for unitaries in matrix element form become\n\\sum _l U_{il}U^*_{jl} = \\delta _{ij}\n\\sum _l U^*_{li}U_{lj} = \\delta _{ij}"},"Quantum-Information/Foundations/Partial-trace":{"slug":"Quantum-Information/Foundations/Partial-trace","filePath":"../PhysicsVault/Quantum Information/Foundations/Partial trace.md","title":"Partial trace","links":["Quantum-Information/Foundations/Composite-systems","Quantum-Information/Open-system-dynamics/Quantum-channel-representations"],"tags":[],"content":"Given an operator \\theta_{AB} lying in a composite system \\mathcal{H}_{AB}:\n\\theta_{AB} \\in \\mathcal{L}\\left(\\mathcal{H}_{AB}\\right)\nthe partial trace operation can be performed on the operator, where a trace is performed only on the elements of one of the systems composing \\mathcal{H}_{AB}:\n\\begin{split}\n\\theta _B=\\tr _A \\theta _{AB} &amp;\\equiv \\sum _i\\prescript{}{A}{\\bra{\\phi_i}}\\theta_{AB}\\ket{\\phi_i}_{A},\\\\\n\\theta _A=\\tr _B \\theta _{AB} &amp;\\equiv \\sum _i\n\\prescript{}{B}{\\bra{\\psi_i}}\\theta_{AB}\\ket{\\psi_i}_{B},\n\\end{split}\nwhere \\{\\ket{\\phi _i}_A\\}_i and \\{\\ket{\\psi _j}_B\\}_j are bases for the systems composing \\mathcal{H}_{AB}.\nIt can be proven that the partial trace operation is a LCPT map."},"Quantum-Information/Foundations/Partial-transpose":{"slug":"Quantum-Information/Foundations/Partial-transpose","filePath":"../PhysicsVault/Quantum Information/Foundations/Partial transpose.md","title":"Partial transpose","links":["Quantum-Information/Quantum-Computation/Computational-basis","Quantum-Information/Entanglement/Bell-states","Quantum-Information/Entanglement/Entangled-states"],"tags":[],"content":"Take a Computational basis \\{\\ket{k}\\}_k of a system \\mathcal{H} and an operator acting upon that space \\theta \\in \\mathcal{L}(\\mathcal{H}), we find the matrix elements of that operator in the given basis\n\\theta _{mn} \\equiv \\matel{m}{\\theta}{n}\n\\theta =\\sum_{mn}\\theta_{mn}\\op{m}{n}\nThen, we define the partial transpose operation through the action of the map\n\\theta \\mapsto T(\\theta) = \\theta ^T \\equiv\\sum_{mn}\\theta_{mn}\\op{n}{m}\nUsing linearity:\nT(\\op{m}{n}) = \\op{n}{m} \\qquad\\forall m,n\nPositivity but no complete positivity\nWe want to prove that this map is positive but not completely positive\n\nPositivity: this is easy, the transpose does not change the eigenvalues of a matrix\nComplete positivity: we just need to find a counter-example. consider a qubit in the system S and a reference system R. Then, consider the maximally entangled state in the system SR:\n\\theta _{SR} = \\ket{\\psi ^+}_{SR}\\bra{\\psi ^+}\n\\ket{\\psi ^+}_{SR} \\equiv \\frac{1}{\\sqrt{2}}\\left(\\ket{0}_S\\ket{0}_R+\\ket{1}_S\\ket{1}_R\\right)\nBy direct computation, we find that\n(T_S\\otimes\\chid_R)\\theta_{SR} \\propto \\op{00}{00}+\\op{11}{11}+\\op{10}{01}+\\op{01}{10}\nso\n (T_S\\otimes\\chid_R)\\theta_{SR} \\sim\\begin{pmatrix}1&amp;0&amp;0&amp;0\\\\0&amp;0&amp;1&amp;0\\\\0&amp;1&amp;0&amp;0\\\\0&amp;0&amp;0&amp;1\\end{pmatrix}\nwhich is not positive.\n\nThe partial transpose operation only makes sense at a local level (a basis needs to be selected), so applying it to an entangled system leads to producing a non-physical system."},"Quantum-Information/Foundations/Pauli-operators":{"slug":"Quantum-Information/Foundations/Pauli-operators","filePath":"../PhysicsVault/Quantum Information/Foundations/Pauli operators.md","title":"Pauli operators","links":["Group-Theory/Group"],"tags":[],"content":"The Pauli operators are the elements of the \\mathrm{su}(2) algebra. In quantum computation, they are usually denoted by X,Y,Z:\nX \\sim \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0\\end{pmatrix}\nY \\sim \\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0\\end{pmatrix}\nZ \\sim \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1\\end{pmatrix}\nThey are hermitian and trace-less operators.\nPauli algebra\nDenote a the Pauli matrices with:\n\\sigma_1 = X\\quad\\sigma_2 = Y\\quad \\sigma_3 = Z\nThe algebra of the group is:\n\\left[\\sigma_i,\\sigma_j\\right]=2\\epsilon_{ijk}\\sigma_k\nThe anticommutator relation is:\n\\left\\{\\sigma_i,\\sigma_j\\right\\}=2\\delta_{ij}\nA useful relation to remember is:\n\\sigma_i\\sigma_j =\\delta_{ij} +i\\epsilon_{ijk}\\sigma_k\nPauli group for n qubits\nWe can consider the action of Pauli operators P_i =\\mathrm{Id},X,Y,Z acting on n qubits. This is a representation of the Pauli Group:\n\\mathcal{P}_n\\equiv \\left\\{\\omega \\bigotimes_{i=0}^{n-1}P_i: \\omega \\in\\left\\{1,-1,i,-i\\right\\}\\right\\}"},"Quantum-Information/Foundations/Polar-decomposition":{"slug":"Quantum-Information/Foundations/Polar-decomposition","filePath":"../PhysicsVault/Quantum Information/Foundations/Polar decomposition.md","title":"Polar decomposition","links":[],"tags":[],"content":"Given a linear operator in a Hilbert space \\mathcal{H}:\n\\theta \\in \\mathcal{L}(\\mathcal{H})\nits polar decomposition is given by\n\\theta = UJ = KU\nwhere U is a unitary operator and\nJ\\equiv \\sqrt{\\theta^\\dagger\\theta}\\qquad K\\equiv\\sqrt{\\theta\\theta^\\dagger}\nare positive semidefinite operators\nProof\nWe prove the first identity, the second one follows\n\\theta = UJ \nExpand J in the spectral decomposition:\nJ\\equiv \\sqrt{\\theta ^\\dagger \\theta} = \\sum _i \\lambda _i \\op{i}{i}\nIn order to simplify the proof, assume \\lambda_ i &gt;0, even though the result can also be proven for the general case \\lambda_ i \\geq 0; then, define:\n\\ket{\\psi_i} \\equiv \\theta \\ket{i} \n\\ip{\\psi _i}{\\psi _j} = \\matel{i}{\\theta ^\\dagger \\theta}{j} =\\matel{i}{\\sqrt{\\theta ^\\dagger \\theta}\\sqrt{\\theta ^\\dagger \\theta}}{j} = \\lambda ^2 _i\\delta_{ij}\nThis means that we can define a new orthonormal basis:\n\\ket{e _i} \\equiv \\frac{1}{\\lambda _i}\\ket{\\psi _i}\nThis means that there exists a unitary transformation U such that:\n\\ket{e_i}= U\\ket{i}\\quad \\forall i\nU\\equiv \\sum_i \\op{e_i}{i}\nNow we just need to prove that \\theta = UJ:\nUJ = \\sum _{ij} \\op{e_i}{i}\\op{j}{j} \\lambda_{j} = \\sum _i \\lambda _i \\op {e_i}{i}\nIn order to obtain the needed result, we need to show that:\n\\ket{\\psi _i} \\equiv \\theta \\ket{i}= UJ \\ket{i}\nUJ \\ket{j} = \\sum _i \\lambda _i \\op {e_i}{i}\\ket{j} = \\lambda_{j}\\ket{e_j} = \\ket{\\psi _j} \nThe second identity follows:\n\\theta = UJU^\\dagger U\\equiv K U\nwhere K \\equiv UJU^\\dagger \\geq 0, we need to prove K = \\sqrt{\\theta \\theta ^\\dagger}:\nK = \\theta U^\\dagger\nKK = KK^\\dagger =\\theta \\theta ^\\dagger"},"Quantum-Information/Foundations/Pure-states":{"slug":"Quantum-Information/Foundations/Pure-states","filePath":"../PhysicsVault/Quantum Information/Foundations/Pure states.md","title":"Pure states","links":["Quantum-Information/Foundations/Closed-systems","Quantum-Information/Foundations/Density-matrix-operators"],"tags":[],"content":"Pure states are normalized elements of a Hilbert space.\n\\ket{\\psi} \\in\\mathcal{H}\nPhysically speaking, they encode the information needed to describe the state of a closed system. In terms of density operators, they are identified by the property:\n\\tr\\rho ^2 = 1\nso that\n\\exists \\ket{\\psi}\\in\\mathcal{H}: \\rho = \\op{\\psi}{\\psi}"},"Quantum-Information/Foundations/Purification":{"slug":"Quantum-Information/Foundations/Purification","filePath":"../PhysicsVault/Quantum Information/Foundations/Purification.md","title":"Purification","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Composite-systems","Quantum-Information/Foundations/Partial-trace","Quantum-Information/Foundations/Schmidt-decomposition"],"tags":[],"content":"Given a mixed state (see Density matrix operators) \\rho _A\\in\\sigma(\\mathcal{H}_A), it is always possible to introduce an auxiliary system R such that the state of the composite system AR is pure and the Partial trace over the auxiliary system returns the original state.\n\\forall \\rho _A\\in\\sigma(\\mathcal{H}_A), \\exists \\mathcal{H}_R:\n\\rho_{AR}\\in\\sigma(\\mathcal{H}_{AR}) \\textrm{ is pure and }\\tr_R\\rho_{AR} = \\rho _A \nProof\nWe can build the purified state directly for a generic \\rho _A:\n\\rho _A = \\sum _i p_i \\ket{\\psi_i}_A\\bra{\\psi_i}\nwe can always choose the dimension of the reference system and we pick an orthonormal basis for it \\{\\ket{i}_R\\}_i; then we build the pure state:\n\\ket{\\psi}_{AB} \\equiv \\sum _i \\sqrt{p_i}\\ket{\\psi_i}_A\\ket{i}_B\nwe can verify by direct computation that this state is correctly normalized and the partial trace over B satisfies the requirement.\nDifferent purifications\nThe purification process is not unique and different purifications can be found. Given \\rho _A and its purification \\ket{\\psi}_{AR}, we have:\n\\ket{\\psi}_{AR},\\ket{\\psi &#039;}_{AR} \\,\\textrm{ are two different purifications of }\\rho _A\n\\Updownarrow\n\\exists U_R \\textrm{ local unitary on } R:\\ket{\\psi &#039;}_{AR} = \\left(\\mathrm{Id}_A\\otimes U_R\\right)\\ket{\\psi}_{AR}\n\\Uparrow\nThis is easy, just perform the partial trace on R.\n\\Downarrow\nApply the Schmidt decomposition:\n\\ket{\\psi ^{\\prime}}_{AR} = \\sum _k \\lambda _k \\ket{\\phi ^{(k)}}_A \\ket{\\varphi ^{\\prime(k)}}_R\n\\ket{\\psi }_{AR} = \\sum _k \\lambda _k \\ket{\\phi ^{(k)}}_A\\ket{\\varphi  ^{(k)}}_R\nGiven that \\ket{\\varphi  ^{(k)}}_R and \\ket{\\varphi  &#039;^{(k)}}_R form a basis for R, they must be linked by a unitary transformation, we call it U_R, proving the theorem."},"Quantum-Information/Foundations/Qubits":{"slug":"Quantum-Information/Foundations/Qubits","filePath":"../PhysicsVault/Quantum Information/Foundations/Qubits.md","title":"Qubits","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Foundations/Pure-states"],"tags":[],"content":"Qubits are usually considered the information units of quantum information. Mathematically speaking, they are states of the density matrix space of a 2 dimensional Hilbert space, whose basis is generally chosen from the eigenvectors of the Pauli operators.\n\\rho \\in \\sigma(\\mathcal{H}_2)\n\\rho \\sim \\begin{pmatrix}p &amp; \\gamma \\\\ \\gamma ^* &amp; 1-p\\end{pmatrix}\nwhere 0\\leq p \\leq 1 and\n\\abs{\\gamma} \\leq \\sqrt{p(1-p)}\nThis relation is saturated by pure states.\nBloch sphere\n\nAn insightful representation for these objects is given by the Bloch sphere, depicted above.\nAny linear operator acting on \\mathcal{H}_2 can be expressed as a linear combination of Pauli operators and the identity:\n\\theta\\in\\mathcal{L}(\\mathcal{H}_2)\n\\theta = \\sum _\\mu \\alpha _\\mu\\sigma _\\mu\n\\sigma _\\mu \\equiv (1,\\vec{\\sigma})\nIn the case of density matrix operators \\rho, the constraints on the operators themselves translate into constraints on the a_\\mu:\n\n\\rho = \\rho ^\\dagger\\Rightarrow \\alpha_\\mu \\in\\mathbb{R} \\quad\\forall \\mu\n\\tr \\rho =1\\Rightarrow \\alpha _0 = 1/2\n\\rho \\geq 0\\Rightarrow \\norm{\\vec{\\alpha}}\\leq 1/2,\\qquad \\alpha _\\mu \\alpha ^\\mu \\geq 0\nWe define the Bloch vector (v in the picture, r here) as \\vec{r} \\equiv 2\\vec{\\alpha}, so that:\n\n\\rho =\\frac{1}{2}\\left(\\id + \\vec{r}\\cdot\\vec{\\sigma}\\right)\n\\norm{\\vec{r}}\\leq 1\nPure states saturate the last inequality."},"Quantum-Information/Foundations/Schmidt-decomposition":{"slug":"Quantum-Information/Foundations/Schmidt-decomposition","filePath":"../PhysicsVault/Quantum Information/Foundations/Schmidt decomposition.md","title":"Schmidt decomposition","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Composite-systems","Quantum-Information/Foundations/Singular-Value-Decomposition-(SVD)","Quantum-Information/Foundations/Partial-trace"],"tags":[],"content":"The Schmidt decomposition theorem allows to distinguish entangled states from separable states (see Density matrix operators) when the state of the composite system is pure\nTheorem\nGiven a pure joint state \\ket{\\psi }_{AB}\\in\\mathcal{H}_{AB} and orthonormal bases for the composing systems A,B, \\{\\ket{i}_A\\}_i , \\{\\ket{j}_B\\}_j,\n\\ket{\\psi}_{AB} = \\sum_{ij}\\alpha _{ij} \\ket{i}_A\\ket{j}_B\n\\alpha _{ij} \\equiv \\prescript{}{A}{\\bra{i}}\\prescript{}{B}{\\bra{j}}\\,\\ket{\\psi}_{AB}\\qquad\\sum_{ij}\\abs{\\alpha _{ij}}^2 =1\nThe Schmidt decomposition theorem states that \\exists \\{\\ket{\\phi ^{(i)}}_A\\}_i, \\{\\ket{\\varphi ^{(j)}}_B\\}_j  bases for the composing systems A,B, and \\exists \\{\\lambda _k\\}_k, \\lambda _k\\geq 0\\in \\mathbb{R}, \\sum_k \\lambda _k ^2 =1 such that:\n\\ket{\\psi } _{AB} = \\sum _{k=1} ^r \\lambda _k \\ket{\\phi ^{(k)}}_A\\ket{\\varphi ^{(k)}}_B\nwhere r is called the Schmidt rank of the state,\nr\\leq \\min \\{\\dim\\mathcal{H}_A,\\dim\\mathcal{H}_B\\}\nProof\n\\ket{\\psi}_{AB} = \\sum_{ij}\\alpha _{ij} \\ket{i}_A\\ket{j}_B\n\\alpha _{ij} is generally a rectangular matrix, however it can always be cast into a square matrix by filling the shorter side with 0 entries. Assume it is square then, without loss of generality. The SVD can be applied to it:\n\\alpha _{ij} = \\sum _{l} U_{il}D_{ll} V_{lj}\nSubstituting into the expression of the joint state:\n\\ket{\\psi}_{AB} = \\sum_{ij}\\sum _{l} U_{il}D_{ll} V_{lj} \\ket{i}_A\\ket{j}_B\nUnitary transformations send a basis into another basis; define the two new bases:\n\\ket{\\phi ^{(l)}}_A\\equiv \\sum_i U_{il}\\ket{i}_A\n\\ket{\\varphi ^{(l)}}_B\\equiv \\sum_j U_{jl}\\ket{j}_B\nInitially we have sent A into a higher dimensional space; is the new basis actually a basis for the original A? In order to have an \\alpha which presents the 0’s in the correct spots, those 0’s need to be in the same positions in U, so everything works. The joint state becomes\n\\ket{\\psi}_{AB} = \\sum _{l} D_{ll}\\ket{\\phi ^{(l)}}_A\\ket{\\varphi ^{(l)}}_B\nThe D_{ll} are non negative, is the sum of their squares =1?\n\\tr D^2 = \\tr UDDU^\\dagger = \\tr UDVV^\\dagger DU^\\dagger = \\tr \\alpha ^\\dagger\\alpha = 1\ntherefore the D_{ll} are exactly the \\lambda _l of the theorem.\nr corresponds to the rank of D\n\\mathrm{rank} D =\\mathrm{rank}\\sqrt{\\alpha ^\\dagger\\alpha} \\leq \\min \\{\\dim\\mathcal{H}_A,\\dim\\mathcal{H}_B\\}\nImplications\nAfter performing a Schmidt decomposition, if we apply the Partial trace to the joint state it becomes clear that the \\lambda ^2 _k are the eigenvalues of the reduced density matrix, with one of the bases \\{\\ket{\\phi ^{(i)}}_A\\}_i, \\{\\ket{\\varphi ^{(j)}}_B\\}_j being composed of the eigenvectors of the operator. This means that the reduced density matrices of a joint pure state are isospectral.\nFurthermore, if the joint state is separable, we know automatically that r=1, so that entangled pure states share the property r\\neq 1."},"Quantum-Information/Foundations/Singular-Value-Decomposition-(SVD)":{"slug":"Quantum-Information/Foundations/Singular-Value-Decomposition-(SVD)","filePath":"../PhysicsVault/Quantum Information/Foundations/Singular Value Decomposition (SVD).md","title":"Singular Value Decomposition (SVD)","links":["Quantum-Information/Foundations/Polar-decomposition"],"tags":[],"content":"It is a generalization of diagonalization for non-hermitian operators.\n\\forall \\theta \\in \\mathcal{L}(\\mathcal{H}), \\exists U,V \\textrm{ unitaries}, D\\textrm{ diagonal}, D\\geq 0 : \\theta = UDV\nProof\nThe proof relies on the Polar decomposition of \\theta:\n\\theta = KU = VDV^\\dagger U \\equiv VDU_1\nwhere U_1 is still unitary\nSpectrum\nBy construction, the SVD eigenvalues (i.e. the eigenvalues of D) are the same as those of the operators K,J in the polar decomposition."},"Quantum-Information/Foundations/Superoperators":{"slug":"Quantum-Information/Foundations/Superoperators","filePath":"../PhysicsVault/Quantum Information/Foundations/Superoperators.md","title":"Superoperators","links":[],"tags":[],"content":"Superoperators are mathematical transformations that send operators into operators:\n\\Phi \\textrm{ superoperator}\n\\Phi: \\mathcal{L}(\\mathcal{H}_{in})\\mapsto\\mathcal{L}(\\mathcal{H}_{out})"},"Quantum-Information/Foundations/Trace-norm":{"slug":"Quantum-Information/Foundations/Trace-norm","filePath":"../PhysicsVault/Quantum Information/Foundations/Trace norm.md","title":"Trace norm","links":["Quantum-Information/Foundations/Polar-decomposition"],"tags":[],"content":"The trace norm for an operator \\theta is defined as follows\n\\norm{\\theta}_1 \\equiv \\tr \\sqrt{\\theta ^\\dagger \\theta}\nProperties\n\nThe trace norm of an operator is the same as the trace norm of its hermitian,\n\\norm{\\theta}_1 = \\norm{\\theta ^\\dagger}_1\nwhich can be proven thanks to the Polar decomposition:\n\\theta = KU = UJ\nwhere K,J have the same spectrum\n\n\\tr \\sqrt{\\theta ^\\dagger \\theta} = \\tr \\sqrt{J ^\\dagger J}\n"},"Quantum-Information/Foundations/Vectorization":{"slug":"Quantum-Information/Foundations/Vectorization","filePath":"../PhysicsVault/Quantum Information/Foundations/Vectorization.md","title":"Vectorization","links":[],"tags":[],"content":"Given a matrix\nM_{B\\leftarrow A}=\\sum_{ij}m_{ij}\\ket{i}_B\\bra{j}_A,\nthen its vectorization is given by:\n\\ketvec{M_{B\\leftarrow A}}\\equiv\\mathrm{vec}\\left(M_{B\\leftarrow A}\\right) = \\sum_{ij}m_{ij}\\ket{j}_A\\ket{i}_B"},"Quantum-Information/Measurements/Born-rule":{"slug":"Quantum-Information/Measurements/Born-rule","filePath":"../PhysicsVault/Quantum Information/Measurements/Born rule.md","title":"Born rule","links":["Quantum-Information/Measurements/POVM's","Quantum-Information/Foundations/Ensembles","Quantum-Information/Foundations/Density-matrix-operators"],"tags":[],"content":"Given a state \\ket{\\psi}\\in \\mathcal{H} and a projective measurement device, characterized by the observable \\theta =\\sum _j\\lambda _j \\op{j}{j}, the Born rule predicts the rate of a given measurement outcome j\nP_j(\\ket{\\psi}) = \\abs{\\ip{j}{\\psi}}^2\nBorn rule for ensambles\nSuppose that a projective measurement \\theta =\\sum _j\\lambda _j \\op{j}{j} is performed on an ensemble generated by a state preparation device \\varepsilon\n\\varepsilon\\equiv \\left\\{\\ket{\\psi}_i\\in\\mathcal{H}, \\quad p_i\\textrm{ probabilty distribution}\\right\\}\nthen, the Born rule in this context becomes\nP_j (\\varepsilon) = \\sum _k p_k \\abs{\\ip{j}{\\psi _k}}^2\nBorn rule for density matrices\nUsing Density matrix operators\n\\rho = \\sum_k p_k\\op{\\psi_k}{\\psi _k}\nThe Born rule becomes\nP_j(\\rho) = \\ev{j}{\\rho}"},"Quantum-Information/Measurements/Helstrom's-theorem":{"slug":"Quantum-Information/Measurements/Helstrom's-theorem","filePath":"../PhysicsVault/Quantum Information/Measurements/Helstrom's theorem.md","title":"Helstrom's theorem","links":["Quantum-Information/Measurements/POVM's","Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Ensembles","Quantum-Information/Foundations/Trace-norm"],"tags":[],"content":"Helstrom’s theorem provides a lower bound on the error associated with a POVM built to discriminate the two states composing a given ensemble.\n\\varepsilon = \\left\\{\\rho _1,\\rho _2;p_1,p_2=1-p_1\\right\\}\nDenote the POVM as\n\\{E_1,E_2\\}\nP_i(\\rho _j) = \\tr(E_i\\rho_j)\nWe define the error probability by summing the probabilities all possible sources of error\nP_{error} = p_1P_2(\\rho _1)+ p_2P_1(\\rho _2)\nStatement\n\\min P_{error} = \\frac{1}{2} \\left(1-\\norm{p_1\\rho _1 - p _2 \\rho _2}_1\\right)\nwhere \\norm{\\cdot}_1 is the Trace norm.\n\n\\min P_{error} \\leq \\frac{1}{2}\nIf \\rho _1, \\rho _2 are orthogonal:\n\\rho _1\\rho _2 = \\rho _1 \\rho _2 = 0\nthen \\min P_{error}=0.\n\nProof\n"},"Quantum-Information/Measurements/Naimark's-theorem":{"slug":"Quantum-Information/Measurements/Naimark's-theorem","filePath":"../PhysicsVault/Quantum Information/Measurements/Naimark's theorem.md","title":"Naimark's theorem","links":["Quantum-Information/Measurements/POVM's","Quantum-Information/Foundations/Ensembles"],"tags":[],"content":"\nNaimark’s dilation theorem guarantees that a POVM set identifies at least one measurement apparatus (parallelism with ensemble equivalence).\nStatement\nGiven a system S in the state \\rho _S and a set of operators satisfying\n\nE_j \\geq 0\\qquad \\forall j\n\\sum _j E_j = \\id\nThen we can always choose a system R in the state \\tau _R and a measurement unitary V_{SR} such that\n\nP_j(\\rho) = \\tr (E_j \\rho)\nProof\nWe construct the measurement unitary and the reference system given a certain POVM set; we choose the dimension of R to match the number of possible measurement outcomes. Then, we specify the action of the unitary on the states \\ket{\\psi}_S\\ket{0}_R:\nV_{SR} \\ket{\\psi}_S\\ket{0}_R\\equiv\\sum _j \\left(V_j ^{(S)}\\sqrt{E_j ^{(S)}}\\ket{\\psi} _S\\right)\\ket{j}_R\nWhere V_j ^{(S)} is a generic local unitary. Is the scalar product conserved on the states \\ket{\\psi}_S\\ket{0}_R?\n\\prescript{}{R}{\\bra{0}}\\prescript{}{S}{\\bra{\\phi}} \\ket{\\psi}_S\\ket{0}_R =\\prescript{}{S}{\\bra{\\phi}} \\ket{\\psi}_S =\\prescript{}{R}{\\bra{0}}\\prescript{}{S}{\\bra{\\phi}}V^\\dagger_{SR}V_{SR} \\ket{\\psi}_S\\ket{0}_R\n\\prescript{}{R}{\\bra{0}}\\prescript{}{S}{\\bra{\\phi}}V^\\dagger_{SR}V_{SR} \\ket{\\psi}_S\\ket{0}_R = \\sum _j\\prescript{}{S}{\\bra{\\phi}}E_j\\ket{\\psi}_S = \\prescript{}{S}{\\bra{\\phi}} \\ket{\\psi}_S\nThe unitary can be extended to all the other subspaces. Finally, performing a projective measurement on the reference system (the process is linear so we can focus on the special case where \\rho is a pure state)\n\\rho _S = \\ket{\\psi}_S\\bra{\\psi}\nP_j (\\rho) = \\tr_S\\left( \\,\\prescript{}{R}{\\matel{j}{V_{SR}}{0}}_R \\,\\ket{\\psi}_S\\bra{\\psi}\\,\\prescript{}{R}{\\matel{0}{V_{SR}^\\dagger }{j}}_R\\right) = ...=\\tr(E_j\\rho)"},"Quantum-Information/Measurements/Non-orthogonal-state-discrimination":{"slug":"Quantum-Information/Measurements/Non-orthogonal-state-discrimination","filePath":"../PhysicsVault/Quantum Information/Measurements/Non orthogonal state discrimination.md","title":"Non orthogonal state discrimination","links":["Quantum-Information/Foundations/Pure-states","Quantum-Information/Measurements/POVM's"],"tags":[],"content":"Potentially, an infinite amount of classical information could be encoded into a qubit (or any quantum system); however, the problem is not the encoding, but rather the decoding. In fact, it can be proven that only orthogonal states can be distinguished through a one-shot quantum measurement process.\nConsider two non orthogonal Pure states \\ket{\\psi _1},\\ket{\\psi _2}\n\\ip{\\psi_1}{\\psi _2}\\neq 0\nand a POVM tentatively capable of distinguishing between the two\n\\exists? \\{E_1,E_2\\}:\nP_{i}(\\ket{\\psi_j}) = \\tr\\left(\\op{\\psi _j}{\\psi_j }E_i\\right) = \\delta _{ij}\nFrom E_1 + E_2 = \\id:\n\\ev{\\psi_1}{E_2} = \\ev{\\psi_1}{1- E_1} = 0\n\\ev{\\psi_1}{E_1} =\\tr(E_1\\op{\\psi _1}{\\psi_1})= 1\nSince E_i\\geq 0, their eigenvalues are non negative.\n\\left\\{\\begin{array}{l}\\ev{\\psi_1}{E_2} \\geq 0 \\\\ \\ev{\\psi_1}{E_2} = 0\\end{array}\\right.\\quad\\Rightarrow \\exists\\lambda^{(2)}_1 = 0, E_2\\ket{\\psi_1} = \\lambda^{(2)}_1\\ket{\\psi _1}\nAt the same time, \\ket{\\psi _2} is also an eigenvector of E_2, with associated eigenvalue 1. But that would imply that  \\ket{\\psi _1},\\ket{\\psi _2} form an eigenbasis, meaning they are orthogonal, therefore this POVM does not exist."},"Quantum-Information/Measurements/POVM's":{"slug":"Quantum-Information/Measurements/POVM's","filePath":"../PhysicsVault/Quantum Information/Measurements/POVM's.md","title":"POVM's","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Open-systems","Quantum-Information/Open-system-dynamics/Quantum-channel-representations","Quantum-Information/Measurements/Born-rule","Quantum-Information/Measurements/Naimark's-theorem","Quantum-Information/Foundations/Polar-decomposition"],"tags":[],"content":"Measurement processes in quantum mechanics are generalized by the POVM (Positive Operator-Valued Measure) formalism\n\nThe measurement process goes as follows: the system S in the state \\rho _S is coupled with a reference system R in the state \\tau _R (ideally, this can be sent to a pure state often denoted with \\ket{0}), which interacts with S through a global unitary V_{SR} (see Open systems, Quantum channel representations). The evolved global state is:\n\\rho &#039; _{SR} = V_{SR} \\left(\\rho _S\\tau _R\\right)V_{SR}^\\dagger\nThen we can perform a projective measurement on the reduced density matrix in R\n\\tau &#039; _R = \\tr _S\\rho &#039; _{SR} =\\tr_S\\left( V_{SR} \\left(\\rho _S\\tau _R\\right)V_{SR}^\\dagger\\right)\nThe rate for each measurement outcome is computed through the Born rule:\nP_j (\\rho) = \\prescript{}{R}{\\ev{j}{\\tau &#039; _R}}_R = \\tr_S\\left(\\prescript{}{R}{\\ev{j}{V_{SR} \\left(\\rho _S\\tau _R\\right)V_{SR}^\\dagger}}_R \\right)\nUsing a spectral decomposition for \\tau _R\n\\tau _r = \\sum _k q_k \\ket{k}_R\\bra{k}\nP_j (\\rho) = \\tr_S\\left(\\sum _k q_k\\,\\prescript{}{R}{\\matel{j}{V_{SR}}{k}}_R \\,\\rho _S\\,\\prescript{}{R}{\\matel{k}{V_{SR}^\\dagger }{j}}_R\\right)\nWe define a set of operators:\nE_j \\equiv\\sum _k q_k\\, \\prescript{}{R}{\\matel{k}{V_{SR}^\\dagger }{j}}_R\\,\\,\\prescript{}{R}{\\matel{j}{V_{SR}}{k}}_R\nFor all j; these operators act on the system S so that the Born rule becomes:\nP_j (\\rho) =\\tr (E_j \\rho)\nAxiomatic definition\nA POVM is given by a set of operators \\{E_j\\}_j that satisfy the following properties:\n\nE_j \\geq 0\\qquad \\forall j\n\\sum _j E_j = \\id, which is needed for \\sum _j P_j =1\n\nProjective measurements\nProjective measurements are a special case of POVM’s:\nE_j = \\op{j}{j}\n\\tr(E_j\\rho) = \\ev{j}{\\rho}\nwhich reproduces the Born rule\nEvolution under measurement\nUsing the most general evolution during the measurement process, found explicitly in Naimark’s theorem:\nV_{SR} \\ket{\\psi}_S\\ket{0}_R\\equiv\\sum _j \\left(V_j ^{(S)}\\sqrt{E_j ^{(S)}}\\ket{\\psi} _S\\right)\\ket{j}_R\nDefine:\nM_j ^{(S)}\\equiv V_j ^{(S)}\\sqrt{E_j ^{(S)}}\nCompare this with the Kraus representation, where the M_j‘s are the Kraus operators and the \\sqrt{E_j ^{(S)}} represent the Polar decomposition of the operators.\nFocusing on the system S and assuming to have measured the outcome j:\n\\ket{\\psi }_S \\overset{j}{\\mapsto}\\frac{1}{\\sqrt{N}}M_j ^{(S)}\\ket{\\psi} _S\nwhere N is just the normalization, equal to the probability of measuring j:\nN=  P_j(\\ket{\\psi}) = \\tr(E_j\\op{\\psi}{\\psi})\nThis process is clearly non-linear, it becomes such if we assume to have performed the measurement process while not having checked the outcome.\nIn the general mixed state case:\n\nIf we check the outcome:\n\n\\rho_S \\overset{j}{\\mapsto}\\frac{1}{N}M_j ^{(S)}\\rho_S M^{(S)\\dagger}_j\n\nIf we don’t:\n\n\\rho_S \\mapsto \\sum _j M_j ^{(S)}\\rho_S M^{(S)\\dagger}_j\ncompare this with the Kraus representation of quantum channels\nExamples\nQubit population\n\nOptic fiber\n"},"Quantum-Information/Measurements/Quantum-state-tomography":{"slug":"Quantum-Information/Measurements/Quantum-state-tomography","filePath":"../PhysicsVault/Quantum Information/Measurements/Quantum state tomography.md","title":"Quantum state tomography","links":["Quantum-Information/Measurements/Non-orthogonal-state-discrimination","Quantum-Information/Measurements/POVM's","Quantum-Information/Foundations/Ensembles","Quantum-Information/Foundations/Qubits","Quantum-Information/Foundations/Pauli-operators"],"tags":[],"content":"Reasoning\nIt can be proven (see Non orthogonal state discrimination) that we can distinguish two pure states through a POVM only when those two states are orthogonal. When that is not the case, however, we may still be able to discriminate those states by using many copies of them:\n0&lt;\\abs{\\ip{\\psi _1}{\\psi _2}}&lt; 1 \n\\Downarrow\n\\abs{\\left(\\bra{\\psi _1}^{\\otimes N}\\right)\\left(\\ket{\\psi _2}^{\\otimes N}\\right)} = \\abs{\\ip{\\psi _1}{\\psi _2}}^N \\overset{N\\rightarrow\\infty}{\\rightarrow} 0\nMain take: statistics used to recover information.\nTomography\n\nGiven a state preparation device producing an ensemble, we run the state preparation process N times and we perform measurements on the states produced in order to characterize the ensemble.\nQubit example\nRecall the Bloch representation; a qubit is completely characterized by a vector in \\mathbb{R}^3 with norm less than 1. Qubit tomography aims to measure this vector\n\\rho =\\frac{1}{2}\\left(\\id + \\vec{r}\\cdot\\vec{\\sigma}\\right)\nHow to measure \\vec{r}? A useful property:\n\\sigma _i \\sigma _j = \\delta _{ij} + i\\varepsilon _{ijk}\\sigma _k\n\\tr\\left(\\sigma_i\\sigma_j\\right) = 2\\delta _{ij}\n\\Downarrow\n\\tr \\rho \\sigma _j = r_j\nTherefore, we perform projective measurements on the eigenbases of the Pauli operators."},"Quantum-Information/Notable-channels/Amplitude-Damping-Channel-(ADC)":{"slug":"Quantum-Information/Notable-channels/Amplitude-Damping-Channel-(ADC)","filePath":"../PhysicsVault/Quantum Information/Notable channels/Amplitude Damping Channel (ADC).md","title":"Amplitude Damping Channel (ADC)","links":["Quantum-Information/Foundations/Qubits","Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Open-system-dynamics/Minimal-Kraus-representation","Quantum-Information/Open-system-dynamics/Quantum-channel-representations"],"tags":[],"content":"The Amplitude Damping Channel (ADC) \\mathcal{A} is a qubit channel. Given a qubit \\rho\n\\rho \\sim \\begin{pmatrix}p &amp; \\gamma \\\\ \\gamma ^* &amp; 1-p\\end{pmatrix}\nthe corresponding output of the channel is given by\n\\mathcal{A}(\\rho ) \\sim \\begin{pmatrix}p +\\eta(1-p) &amp; \\gamma\\sqrt{1-\\eta} \\\\ \\gamma^*\\sqrt{1-\\eta}  &amp; (1-p)(1-\\eta)\\end{pmatrix}\nThis channel describes an energy dissipation process. The decoherence is expected, we can’t have a channel which just changes the populations of the quantum levels without decoherence, otherwise the map is not positive.\nKraus representation\nThe Minimal Kraus representation of the channel is given by\nK_0 \\sim \\begin{pmatrix}1 &amp; 0 \\\\ 0 &amp; \\sqrt{1-\\eta}\\end{pmatrix}\nK_1 \\sim \\begin{pmatrix}0 &amp; \\sqrt{\\eta} \\\\ 0 &amp; 0\\end{pmatrix}\nStinespring representation\nThe Stinespring representation of the channel is found by defining the total hamiltonian of the qubit S and the environment E\nH = \\sigma _+ ^{(S)}\\otimes\\sigma _- ^{(E)}+\\sigma _- ^{(S)}\\otimes\\sigma _+ ^{(E)}\nwhere\n\\sigma _+ \\equiv \\begin{pmatrix}0 &amp; 0 \\\\ 1 &amp; 0\\end{pmatrix}\n\\sigma _- \\equiv \\begin{pmatrix}0 &amp; 1 \\\\ 0 &amp; 0\\end{pmatrix}\nso that\nU_{SE} = \\exp(-iHt)\nfor a fixed t."},"Quantum-Information/Notable-channels/Bit-flip-channel":{"slug":"Quantum-Information/Notable-channels/Bit-flip-channel","filePath":"../PhysicsVault/Quantum Information/Notable channels/Bit-flip channel.md","title":"Bit-flip channel","links":["Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Notable-channels/Pauli-channels","Quantum-Information/Foundations/Qubits","Quantum-Information/Foundations/Pauli-operators"],"tags":[],"content":"The bit-flip channel \\mathcal{B} is a Pauli channel; its action on a qubit \\rho is given by:\n\\mathcal{B}(\\rho) = (1-p)\\rho +p X\\rho X, \\quad p\\in[0,1]\nNote that:\nX\\ket{0} = \\ket{1}\nX\\ket{1} = \\ket{0}\nSo this channel introduces a probability of swapping the eigenvectors of the Z operator (see Pauli operators)"},"Quantum-Information/Notable-channels/Dephasing-channel":{"slug":"Quantum-Information/Notable-channels/Dephasing-channel","filePath":"../PhysicsVault/Quantum Information/Notable channels/Dephasing channel.md","title":"Dephasing channel","links":["Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Notable-channels/Pauli-channels","Quantum-Information/Foundations/Qubits","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Notable-channels/Bit-flip-channel","Quantum-Information/Quantum-Computation/Hadamard-Gate"],"tags":[],"content":"Qubit\nThe dephasing channel \\mathcal{D} (or phase flip channel) is a Pauli channel; its action on a qubit \\rho is given by:\n\\mathcal{D}(\\rho) = (1-p)\\rho +p Z\\rho Z, \\quad p\\in[0,1]\nNote that:\nZ\\ket{+} = \\ket{-}\nZ\\ket{-} = \\ket{+}\nSo this channel introduces a probability of swapping the eigenvectors of the X operator (see Pauli operators)\nThe dephasing channel can be mapped into a Bit-flip channel through a Hadamard Gate"},"Quantum-Information/Notable-channels/Depolarizing-channel":{"slug":"Quantum-Information/Notable-channels/Depolarizing-channel","filePath":"../PhysicsVault/Quantum Information/Notable channels/Depolarizing channel.md","title":"Depolarizing channel","links":["Quantum-Information/Foundations/Qubits","Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Notable-channels/Pauli-channels"],"tags":[],"content":"The depolarizing channel \\Phi is a qubit channel. Its action on a linear operator \\theta acting on \\mathcal{H}_2 is given by\n\\Phi(\\theta) =  p \\theta +(1-p) (\\id/2)(\\tr\\theta)\nThe last term is needed for explicit linearity in the qubit case. Applying this transformation on the Bloch sphere generates a movement along the radius towards the center of the sphere.\nDepolarizing noise (resistance) is often used as benchmark for quantum devices, as it approximates the combination of all possible noises.\nNote that the depolarizing channel is a Pauli channel."},"Quantum-Information/Notable-channels/Pauli-channels":{"slug":"Quantum-Information/Notable-channels/Pauli-channels","filePath":"../PhysicsVault/Quantum Information/Notable channels/Pauli channels.md","title":"Pauli channels","links":["Quantum-Information/Notable-channels/Dephasing-channel","Quantum-Information/Notable-channels/Bit-flip-channel","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Foundations/Heisenberg-Weyl-operators"],"tags":[],"content":"Qubit\nPauli channels are a generalization of dephasing channels and bit-flip channels. They correspond to applying a random Pauli operator according to a probability distribution:\n\\rho \\mapsto \\sum _{i,j=0} ^1 p_{ij} Z^i X^j \\rho X^j Z^i\nQudit\nThe qudit equivalent to Pauli channels is obtained by replacing the Pauli operators in the map above with the corresponding Heisenberg-Weyl operators:\n\\rho \\mapsto \\sum _{i,j=0} ^{d-1}p_{ij} Z(i) X(j) \\rho X^\\dagger (j) Z^\\dagger (i)"},"Quantum-Information/Open-system-dynamics/Channel-representations-equivalence":{"slug":"Quantum-Information/Open-system-dynamics/Channel-representations-equivalence","filePath":"../PhysicsVault/Quantum Information/Open system dynamics/Channel representations equivalence.md","title":"Channel representations equivalence","links":["Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Open-system-dynamics/Quantum-channel-representations"],"tags":[],"content":"Stinespring to Kraus\nGiven a channel in Stinespring representation (see Quantum channel representations)\n\\Phi \\left(\\rho _A\\right) = \\tr _E \\left[U_{BE\\leftarrow AE}\\left(\\rho _A \\ket{0}_E\\bra{0}\\right)U^\\dagger _{BE\\leftarrow AE}\\right]\nWe can derive its Kraus representation by carrying out the partial trace explicitly\n\\Phi \\left(\\rho _A\\right) = \\sum_l \\prescript{}{E}{\\bra{l}}U_{BE\\leftarrow AE}\\ket{0}_E\\rho _A \\,\\prescript{}{E}{\\bra{0}}U^\\dagger _{BE\\leftarrow AE}\\ket{l}_E\nThen, we define a Kraus element:\nK_l \\equiv \\prescript{}{E}{\\bra{l}}U_{BE\\leftarrow AE}\\ket{0}_E\nK_l :\\mathcal{H_A}\\mapsto\\mathcal{H}_B\nThe resulting Kraus set clearly satisfies\n\\sum_i K_i ^\\dagger K_i =\\id _A\nand finally\n\\Phi\\left(\\rho_A\\right) = \\sum _i K_i \\rho_A K _i ^{\\dagger}\nKraus to Stinespring\nThis one is a little more convoluted\nTODO"},"Quantum-Information/Open-system-dynamics/Choi-theorem":{"slug":"Quantum-Information/Open-system-dynamics/Choi-theorem","filePath":"../PhysicsVault/Quantum Information/Open system dynamics/Choi theorem.md","title":"Choi theorem","links":["Quantum-Information/Foundations/Superoperators","Quantum-Information/Entanglement/Choi-state"],"tags":[],"content":"The complete positiveness of a superoperator \\Psi can be verified by checking the positivity of the associated Choi matrix \\Psi. This is a consequence of Choi’s theorem:\n\\Psi \\textrm{ is completely positive}\\Leftrightarrow \\rho _{\\Psi} \\textrm{ is positive}."},"Quantum-Information/Open-system-dynamics/Choi-Jamiołkowski-isomorphism":{"slug":"Quantum-Information/Open-system-dynamics/Choi-Jamiołkowski-isomorphism","filePath":"../PhysicsVault/Quantum Information/Open system dynamics/Choi-Jamiołkowski isomorphism.md","title":"Choi-Jamiołkowski isomorphism","links":["Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Composite-systems","Quantum-Information/Foundations/Partial-trace","Quantum-Information/Entanglement/Choi-state","Quantum-Information/Foundations/Convex-combinations","Quantum-Information/Foundations/Pure-states","Quantum-Information/Foundations/Partial-transpose","Quantum-Information/Foundations/Purification","Quantum-Information/Foundations/Schmidt-decomposition"],"tags":[],"content":"The Choi-Jamiołkowski isomorphism identifies a one-to-one relation between Quantum channels and a special class of states in a composite system. Given a system S and a reference system R with the same dimension d, We define the space of density matrices whose Partial trace on S reduces to the completely chaotic state:\n\\sigma_{1_R}(\\mathcal{H}_{SR}) = \\left\\{\\rho_{SR}: \\tr_S\\rho _{SR} = \\id_R/d\\right\\}\nThen, any element of \\sigma_{1_R}(\\mathcal{H}_{SR}) is the Choi state of a quantum channel acting on S and any channel acting on S can be described by an element of \\sigma_{1_R}(\\mathcal{H}_{SR}):\n\\rho _{SR} \\in \\sigma_{1_R}(\\mathcal{H}_{SR}) \\leftrightarrow \\Phi\\, LCPT\nSince quantum channels are closed under Convex combinations, \\sigma_{1_R}(\\mathcal{H}_{SR}) is a convex space itself.\nProof\n\\leftarrow\nWe need to prove that given the channel \\Phi and its Choi state \\rho ^\\Phi _{SR} in SR, the action of the channel is described by\n\\Phi \\left(\\ket{\\psi}_S\\bra{\\psi}\\right) = d\\,\\prescript{}{R}{\\bra{\\psi ^*}}\\rho ^\\Phi _{SR}\\ket{\\psi ^*}_R=d\\,\\tr _R \\left(\\ket{\\psi}_R\\bra{\\psi} \\left(\\rho ^\\Phi _{SR}\\right)^{T_R}\\right)\nOnce we achieve this, we only need to prove that \\rho ^\\Phi _{SR} \\in \\sigma_{1_R}(\\mathcal{H}_{SR}), but this trivially comes from the definition of Choi states.\nTake a generic pure state in S:\n\\ket{\\psi}_S =\\sum_{i=0}^{d-1}\\alpha _i \\ket{i}_S\nand define its conjugate state:\n\\ket{\\psi ^*}_S =\\sum_{i=0}^{d-1}\\alpha ^* _i \\ket{i}_S\nThen we can prove that:\n\\Phi \\left(\\ket{\\psi}_S\\bra{\\psi}\\right) = d\\,\\prescript{}{R}{\\bra{\\psi ^*}}\\rho ^\\Phi _{SR}\\ket{\\psi ^*}_R\nin fact:\nd\\,\\prescript{}{R}{\\bra{\\psi ^*}}\\rho ^\\Phi _{SR}\\ket{\\psi ^*}_R = \\sum_{kl}\\Phi\\left(\\ket{k}_S\\bra{l}\\right)\\alpha_k\\alpha ^*_{l} = \\Phi \\left(\\ket{\\psi}_S\\bra{\\psi}\\right)\nAs for the second equality, the left hand side is the expectation value of the Choi state on a vector of R, which can be expressed in trace form:\nd\\,\\prescript{}{R}{\\bra{\\psi ^*}}\\rho ^\\Phi _{SR}\\ket{\\psi ^*}_R =d\\,\\tr_R\\left(\\rho ^\\Phi _{SR} \\,\\ket{\\psi ^*}_R\\bra{\\psi ^*}\\right)\nNow we recognize that:\n\nSince \\ket{\\psi}\\bra{\\psi} is hermitian, \\ket{\\psi^*}\\bra{\\psi^*} = (\\ket{\\psi}\\bra{\\psi})^T, where T is the Partial transpose operation\nThe trace is invariant under transpose\nSo that\n\nd\\,\\prescript{}{R}{\\bra{\\psi ^*}}\\rho ^\\Phi _{SR}\\ket{\\psi ^*}_R =d\\,\\tr_R\\left(\\rho ^\\Phi _{SR} \\,(\\ket{\\psi}_R\\bra{\\psi})^{T_R}\\right) =d\\,\\tr _R \\left(\\ket{\\psi}_R\\bra{\\psi} \\left(\\rho ^\\Phi _{SR}\\right)^{T_R}\\right) \n\\rightarrow\nTake a state \\rho _{SR} \\in \\sigma_{1_R}(\\mathcal{H}_{SR}) and consider one of its purifications using an auxiliary system A\n\\ket{\\psi}_{SRA}:\\tr_A(\\ket{\\psi}_{SRA}\\bra{\\psi}) = \\rho _{SR}\nWe can use Schmidt decomposition to write:\n\\ket{\\psi}_{SRA} = \\sum _l \\lambda _l \\ket{\\varphi _l}_{SA}\\ket{l}_R\nwhere \\{\\ket{\\varphi _l}_{SA}\\} is a basis for SA. The requirement\n\\tr_{SA}(\\ket{\\psi}_{SRA}\\bra{\\psi}) = \\id_R/d\nsets a constraint on the \\lambda _l: they all need to be equal to 1/\\sqrt{d}\n\\ket{\\psi}_{SRA} = \\sum _l \\frac{1}{\\sqrt{d}} \\ket{\\varphi _l}_{SA}\\ket{l}_R\nNow we explicitly take the partial trace wrt A\n\\tr_A(\\ket{\\psi}_{SRA}\\bra{\\psi}) = \\frac{1}{d}\\sum _{ijk}\\prescript{}{A}{\\ip{k}{\\varphi _i}}_{SA}\\,\\prescript{}{SA}{\\ip{\\varphi _j}{k}}_{A} \\otimes\\ket{i}_R\\bra{j}\nIn order to prove that the right-hand side is a Choi state, we try to explicitly build the Kraus set for the associated channel:\nK_ l \\equiv \\sum_m \\prescript{}{A}{\\ip{l}{\\varphi _m}}_{SA}\\,\\,\\prescript{}{S}{\\bra{m}}\n\\sum_l K^\\dagger _l K_l = \\id_S\nThen:\n\\tr_A(\\ket{\\psi}_{SRA}\\bra{\\psi}) = \\frac{1}{d}\\sum_{ijl} K_l \\ket{i}_S\\bra{j} K_l^\\dagger\\otimes\\ket{i}_R\\bra{j}\nwhich is exactly the Choi state associated to the channel."},"Quantum-Information/Open-system-dynamics/Kraus-from-Choi":{"slug":"Quantum-Information/Open-system-dynamics/Kraus-from-Choi","filePath":"../PhysicsVault/Quantum Information/Open system dynamics/Kraus from Choi.md","title":"Kraus from Choi","links":["Quantum-Information/Foundations/Superoperators","Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Entanglement/Choi-state","Quantum-Information/Open-system-dynamics/Choi-theorem","Quantum-Information/Open-system-dynamics/Quantum-channel-representations","Quantum-Information/Foundations/Vectorization"],"tags":[],"content":"If one only has the output of a superoperator acting on a generic input state, determining whether the corresponding map is a channel could be a bit of a challenge. Specifically, while checking the trace conservation and the linearity is usually trivial, confirming the complete positivity is not so easy. One possible recipe to do so is the following:\n\n\n                  \n                  Check if a map is completely positive \n                  \n                \n\n\nFind the Choi matrix associated to the map \\Phi:\n\n\\Phi \\mapsto C_\\Phi \\equiv\\frac{1}{d}\\sum _{ij}\\Phi \\left(\\ket{i}_A\\bra{j}\\right)\\otimes \\ket{i}_R\\bra{j}\n\nCompute the eigenvalues of C_\\Phi\nIf all the eigenvalues are non-negative, the map is completely positive (see Choi theorem).\n\n\n\nThis procedure might work fine for qubits or even qutrits, but increasing the dimensionality could make the eigenvalue problem very hard to solve, especially when we want to solve it analytically (for example, for channels with dependency on a number of parameters or for arbitrary dimensionality).\nAn alternative procedure could consist in finding the Kraus operators from the Choi matrix and checking whether they satisfy the required conditions. How do we do that?\n\n\n                  \n                  Get Kraus operators from Choi matrix \n                  \n                \n\nConsider the Kraus operators K_l of a channel \\Phi, their matrix expression being:\nK_l = \\sum_{mn}K_{mn} ^{(l)} \\op{m}{n}\nThe Vectorization of this objects is:\n\\ketvec{K_l} = \\sum_{mn}K_{mn} ^{(l)} \\ket{m}\\ket{n}\nComputing the Choi matrix using the Kraus representation of \\Phi, it can be seen that:\nC_\\Phi =\\frac{1}{d}\\sum_l\\ketvec{K_l}\\bravec{K_l}\nBasically, the vectorization of a Kraus operator is an eigenvector of the Choi matrix.\nTherefore, the procedure to find the Kraus operators from the Choi matrix works as follows:\n\nCompute the Choi matrix C_\\Phi\nTry to rewrite the Choi matrix so that it is in the form\n\nC_\\Phi =\\frac{1}{d}\\sum_l\\ketvec{K_l}\\bravec{K_l}\n\nFrom \\ketvec{K_l},  apply a reshaping operator \\mathrm{mat}() which from a d^2-dimensional vector outputs a d\\times d matrix whose elements are:\n\n(K_l)_{ij} = \\left(\\mathrm{mat}\\left(\\ketvec{K_l}\\right)\\right)_{ij} = \\left(\\ketvec{K_l}\\right)_{i d + j}\nExample implementation in python:\npython \t  import numpy as np \t  v = np.array([v0, v1, v2, v3]) \t  d = 2 # Dimension of the subsystem  \t  V = v.reshape((d, d)) \t  \n\n"},"Quantum-Information/Open-system-dynamics/Kraus-representation-equivalence":{"slug":"Quantum-Information/Open-system-dynamics/Kraus-representation-equivalence","filePath":"../PhysicsVault/Quantum Information/Open system dynamics/Kraus representation equivalence.md","title":"Kraus representation equivalence","links":["Quantum-Information/Open-system-dynamics/Quantum-channel-representations","Quantum-Information/Foundations/Orthogonality-relation-for-unitaries"],"tags":[],"content":"Given the Kraus sets \\mathcal{K} =\\left\\{K_i\\right\\}_i and \\mathcal{K}^\\prime=\\left\\{K ^\\prime_i\\right\\}_i, they represent the same channel if and only if:\nK ^\\prime_i = \\sum _j \\mathcal{U}_{ij}K_j\nwhere the \\mathcal{U}_{ij} are the matrix elements of an isometry and they satisfy the orthogonality relations"},"Quantum-Information/Open-system-dynamics/LOCC-protocols":{"slug":"Quantum-Information/Open-system-dynamics/LOCC-protocols","filePath":"../PhysicsVault/Quantum Information/Open system dynamics/LOCC protocols.md","title":"LOCC protocols","links":["Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Composite-systems","Quantum-Information/Entanglement/Entangled-states"],"tags":[],"content":"Local Operations and Classical Communications (LOCC) are a class of Quantum channels which respond to a specific protocol: suppose the existence of two parties, Alice and Bob, who share a state in their composite system AB and classical line of communication. Then, they perform a LOCC process if they restrict themselves to doing an arbitrary combination of the following operations:\n\nPerform local operations on their respective systems A and B\nUse the classical communication line to exchange bit of information (e.g. outcomes of measurements)\nLOCC protocols send separable states into separable states (see Density matrix operators), i.e. they do not generate Entangled states.\n"},"Quantum-Information/Open-system-dynamics/Minimal-Kraus-representation":{"slug":"Quantum-Information/Open-system-dynamics/Minimal-Kraus-representation","filePath":"../PhysicsVault/Quantum Information/Open system dynamics/Minimal Kraus representation.md","title":"Minimal Kraus representation","links":["Quantum-Information/Open-system-dynamics/Quantum-channel-representations","Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Open-system-dynamics/Kraus-representation-equivalence"],"tags":[],"content":"A Kraus set \\mathcal{K} = \\left\\{K_i\\right\\}_i is said to be minimal if:\n\\tr(K^\\dagger_iK _j) =c_i \\delta _{ij}\nFor any channel, it is always possible to find a minimal Kraus set (see Kraus representation equivalence)."},"Quantum-Information/Open-system-dynamics/Quantum-channel-representations":{"slug":"Quantum-Information/Open-system-dynamics/Quantum-channel-representations","filePath":"../PhysicsVault/Quantum Information/Open system dynamics/Quantum channel representations.md","title":"Quantum channel representations","links":["Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Foundations/Superoperators","Quantum-Information/Foundations/Partial-transpose","Quantum-Information/Entanglement/Entangled-states","Quantum-Information/Foundations/Composite-systems","Quantum-Information/Entanglement/PPT-criterion","Quantum-Information/Open-system-dynamics/Stinespring-dilation","Quantum-Information/Foundations/Partial-trace","Quantum-Information/Entanglement/Choi-state","Quantum-Information/Open-system-dynamics/Choi-Jamiołkowski-isomorphism"],"tags":[],"content":"Axiomatic representation - LCPT\nQuantum channels are also called LCPT maps, from the requirements that a superoperator needs to satisfy in order to be considered a physical transformation:\n\nLinearity\nComplete Positivity: in general, a positive superoperator is an object that maps positive operators into positive operators; here the requirement is stricter: in fact, given a positive operator in a composite system \\theta _{SR}\\geq 0, \\theta _{SR}\\in\\mathcal{L}(\\mathcal{H}_{SR}), we say that a superoperator \\Phi _S acting on S is completely positive if the operator\n\\Phi_S\\otimes\\chid_R\nis positive for any choice of R.\n\\Phi \\,\\textrm{ is CP}\\Leftrightarrow \\Phi \\otimes \\chid _R \\,\\textrm{ is P} \\quad\\forall R\nAn example of map which is positive but not completely positive can be found in the Partial transpose operation, which can be useful to characterize the Entangled states of a Composite systems, see PPT criterion.\nTrace preservation, meaning that the action of quantum channels leave the trace of the input operator unchanged\n\nStinespring representation\nThis representation is the most physically intuitive one and the one described in Quantum channels. It is based on the action of a Stinespring dilation, for an operator \\theta _A\\in\\mathcal{L}(\\mathcal{H}_A):\n\\mathfrak{U}_{A\\mapsto BE}:\\mathcal{L}(\\mathcal{H}_A)\\mapsto \\mathcal{L}(\\mathcal{H}_{BE})\n\\theta_{A}\\xmapsto{\\mathfrak{U}_{A\\mapsto BE}} U_{BE\\leftarrow AE} \\left(\\theta_{A} \\otimes \\ket{0}_E\\bra{0}\\right)U_{BE\\leftarrow AE}^{\\dagger}\nThe channel, let us call it \\Phi, is then found by taking the Partial trace w.r.t. the environment:\n\\Phi =\\tr_E\\circ\\mathfrak{U}_{A\\mapsto BE}\n\\Phi : \\mathcal{L}(\\mathcal{H}_A)\\mapsto \\mathcal{L}(\\mathcal{H}_{B})\nKraus representation\nThe Kraus representation is characterized by a set of operators \\mathcal{K} = \\left\\{K_i\\right\\}_i on \\mathcal{H} such that:\n\\sum _i K^{\\dagger}_i K_i = \\id\nThe set \\mathcal{K} describes a quantum channel \\Phi, defined by:\n\\Phi\\left(\\rho\\right) = \\sum _i K_i \\rho K _i ^{\\dagger}\nThe set \\mathcal{K} is called Kraus set, while the K_i‘s are called Kraus operators.\nChoi-Jamiołkowski representation\nThe action of a channel \\Phi can be described by its Choi state \\rho _\\Phi:\n\\rho _\\Phi = \\frac{1}{d}\\sum _{ij}\\Phi \\left(\\ket{i}_A\\bra{j}\\right)\\otimes \\ket{i}_R\\bra{j}\nwhere d is the dimension of the input system A, through the relation:\n\\Phi \\left(\\ket{\\psi}_A\\bra{\\psi}\\right) = d\\,\\prescript{}{R}{\\bra{\\psi ^*}}\\rho_\\Phi\\ket{\\psi ^*}_R=d\\,\\tr _R \\left(\\ket{\\psi}_R\\bra{\\psi} \\left(\\rho _\\Phi\\right)^{T_R}\\right)\nwhere\n\\ket{\\psi} =\\sum_{i=0}^{d-1}\\alpha _i \\ket{i} \\Rightarrow\\ket{\\psi ^*} \\equiv \\sum_{i=0}^{d-1}\\alpha^{*} _i \\ket{i}\nand T_A is the Partial transpose acting on A. This is proven in Choi-Jamiołkowski isomorphism.\nLinearity guarantees that this relation works for any input state"},"Quantum-Information/Open-system-dynamics/Quantum-channels":{"slug":"Quantum-Information/Open-system-dynamics/Quantum-channels","filePath":"../PhysicsVault/Quantum Information/Open system dynamics/Quantum channels.md","title":"Quantum channels","links":["Quantum-Information/Foundations/Density-matrix-operators","Quantum-Information/Foundations/Closed-systems","Quantum-Information/Foundations/Open-systems","Quantum-Information/Foundations/Composite-systems","Quantum-Information/Open-system-dynamics/Quantum-channel-representations","Quantum-Information/Foundations/Convex-combinations"],"tags":[],"content":"The idea of a quantum channel refers to a process which takes a quantum state as an input and outputs a different (evolved) quantum state.\nIn traditional quantum mechanics, this process is described by unitary transformations; however, this only works for Closed systems, while a more general approach is needed in the case of Open systems.\nThe main idea behind quantum channels consists in coupling the open system that undergoes evolution (let us call it S) with an external system, called environment (E). We can safely assume that the evolution of the composite system SE is going to be unitary, as we could inglobate in E anything that is not S, making SE a closed system. Then we can evolve the system SE following an appropriate unitary transformation. Finally, performing a partial trace on SE w.r.t. E we can discard all the information related to the environment, which leaves us with the evolved state in the system S.\nThis picture reflects the Stinespring representation of quantum channels, seen in Quantum channel representations.\nSpace of quantum channels\nLCPT channels are closed under Convex combinations\n\\Phi _x \\,\\textrm{ LCPT}\\Rightarrow\\sum_x p_x\\Phi _x\\,\\textrm{ LCPT}\nThe space of LCPT maps is a convex space whose border are identified by unitary transformations."},"Quantum-Information/Open-system-dynamics/Stinespring-dilation":{"slug":"Quantum-Information/Open-system-dynamics/Stinespring-dilation","filePath":"../PhysicsVault/Quantum Information/Open system dynamics/Stinespring dilation.md","title":"Stinespring dilation","links":["Quantum-Information/Foundations/Superoperators"],"tags":[],"content":"A Stinespring dilation \\mathfrak{U}_{A\\mapsto BE} is a superoperator based on the action of an isometry:\nU_{BE\\leftarrow A} \\textrm{ isometry}\n\\mathfrak{U}_{A\\mapsto BE}\\left(\\bullet\\right) \\equiv U_{BE\\leftarrow A}\\bullet U_{BE\\leftarrow A}^{\\dagger}\nSo that, for an operator \\theta _A\\in\\mathcal{L}(\\mathcal{H}_A):\n\\theta_{A}\\xmapsto{\\mathfrak{U}_{A\\mapsto BE}} U_{BE\\leftarrow AE} \\left(\\theta_{A} \\otimes \\ket{0}_E\\bra{0}\\right)U_{BE\\leftarrow AE}^{\\dagger}"},"Quantum-Information/Protocols/Entanglement-distillation-protocol":{"slug":"Quantum-Information/Protocols/Entanglement-distillation-protocol","filePath":"../PhysicsVault/Quantum Information/Protocols/Entanglement distillation protocol.md","title":"Entanglement distillation protocol","links":[],"tags":[],"content":"TODO"},"Quantum-Information/Protocols/Entanglement-swapping":{"slug":"Quantum-Information/Protocols/Entanglement-swapping","filePath":"../PhysicsVault/Quantum Information/Protocols/Entanglement swapping.md","title":"Entanglement swapping","links":["Quantum-Information/Entanglement/Entangled-states","Quantum-Information/Entanglement/PPT-criterion","Quantum-Information/Foundations/Qubits","Quantum-Information/Quantum-Computation/Computational-basis","Quantum-Information/Protocols/Quantum-teleportation"],"tags":[],"content":"\nConsider n labs, that present connections through entanglement. Entanglement swapping tries to compensate for the noise generated by distances between labs, which degrade entanglement. Focus on n=3 example\n\\rho _{ABC}=\\frac{1}{2} \\ket{0}_C\\bra{0}\\,\\ket{\\phi_+}_{AB}\\bra{\\phi _+}+\\frac{1}{2} \\ket{1}_C\\bra{1}\\,\\ket{\\phi_-}_{AB}\\bra{\\phi _-}\nturns out that AB are separable\n\\rho _{AB} = ... = \\frac{1}{2}\\left(\\ket{0}_A\\bra{0}\\,\\ket{0}_B\\bra{0}+\\ket{1}_A\\bra{1}\\,\\ket{1}_B\\bra{1}\\right)\nThe PPT criterion tells us that ABC is entangled. Suppose C measures their qubit in the Computational basis. After the measurement, AB will be maximally entangled. C can send outcome (classically) to AB who now know which Bell pair they share.\nThis is basically the Quantum teleportation protocol, Charlie teleports the qubit C1 to Bob"},"Quantum-Information/Protocols/Impossible-machines":{"slug":"Quantum-Information/Protocols/Impossible-machines","filePath":"../PhysicsVault/Quantum Information/Protocols/Impossible machines.md","title":"Impossible machines","links":["Quantum-Information/Entanglement/Impossible-machines/Bell-telephone","Quantum-Information/Entanglement/Impossible-machines/Quantum-cloner","Quantum-Information/Entanglement/Impossible-machines/Classical-teleportation-machine","Quantum-Information/Entanglement/Impossible-machines/Joint-measurement-of-incompatible-observables","Quantum-Information/Entanglement/Impossible-machines/Universal-NOT-gate"],"tags":[],"content":"The following is a collection of protocols/machines which are forbidden due to the laws of quantum mechanics\n\nBell telephone\nQuantum cloner\nClassical teleportation machine\nJoint measurement of incompatible observables\nUniversal NOT gate\nMany of these machines are impossible due to the impossibility of building a Bell telephone\n\nApproximate impossible machines"},"Quantum-Information/Protocols/Quantum-teleportation":{"slug":"Quantum-Information/Protocols/Quantum-teleportation","filePath":"../PhysicsVault/Quantum Information/Protocols/Quantum teleportation.md","title":"Quantum teleportation","links":["Quantum-Information/Entanglement/Bell-states"],"tags":[],"content":"\nAlice wants to send a qudit state \\ket{\\varphi}_{A^\\prime} in her lab in the system A^\\prime to Bob. Alice and Bob share a previously prepared maximally entangled qudit pair \\ket{\\psi_{0,0}}_{AB} in their respective systems A,B.\n\\ket{\\varphi} = \\sum_{i=0}^{d-1} \\alpha _i \\ket{i},\n\\ket{\\psi_{0,0}}=\\frac{1}{\\sqrt{d}}\\sum_{k=0}^{d-1}\\ket{k}\\ket{k}.\nProtocol:\n\nThe total state at the beginning of the process is:\n\n\\ket{\\psi _{0,0}}_{AB}\\ket{\\varphi}_{A^\\prime} = \\frac{1}{\\sqrt{d}}\\sum_{ij}\\alpha _i\\ket{j}_A\\ket{j}_B\\ket{i}_{A^\\prime}.\n\nAlice performs a projective measurement on the Bell basis on her systems A,A^\\prime:\n\\ket{\\psi _{a,b}}_{AA^\\prime}=\\frac{1}{\\sqrt{d}}\\sum_{j=0}^{d-1}\\left(\\mathrm{Id}^{(A)}\\otimes W_{a,b}^{(A^\\prime)}\\right)\\ket{j}_A\\ket{j}_{A^\\prime}\nIt’s useful to note here that:\n\\sum_k \\prescript{}{A}{\\bra{k}}U_A\\ket{\\psi}_A\\ket{k}_B=U_B\\ket{\\psi}_B\nContracting this state \\ket{\\psi _{a,b}}_{AA^\\prime} with \\ket{\\psi _{0,0}}_{AB}\\ket{\\varphi}_{A^\\prime} we obtain, up to a global phase:\n\\frac{1}{d}X(-b)Z(-a)\\ket{\\varphi}_B.\nwhich means that each outcome (a,b) can happen with the same probability 1/d^2 and the corresponding output state on Bob’s system is Z(-a)X(-b)\\ket{\\varphi}_B.\nAlice sends the outcome (a,b) of the experiment to Bob through a classical communication line.\nBob reads the outcome and performs a unitary transformation Z(a)X(b) on his system, obtaining \\ket{\\varphi}_B.\n"},"Quantum-Information/Protocols/Super-dense-coding":{"slug":"Quantum-Information/Protocols/Super-dense-coding","filePath":"../PhysicsVault/Quantum Information/Protocols/Super-dense coding.md","title":"Super-dense coding","links":["Quantum-Information/Foundations/Qubits","Quantum-Information/Entanglement/Bell-states"],"tags":[],"content":"\nAlice chooses the Qubits she wants to send. In this scenario 1\\mathrm{qbit}= 1\\mathrm{bit}. If we add a maximally entangled state, 1\\mathrm{qbit} +1\\mathrm{ebit}= 2\\mathrm{bit}. Suppose Alice and Bob share a pair of qubits \\ket{\\phi ^+}_{AB} prepared by a third party. This additional resource can be exploited by Alice to send 2 bits of classical info. In fact, Alice can decide to change the pair locally to send it in another Bell state. Then, Alice sends the qubit A to Bob, who now has the whole pair ⇒ he performs projective measurement on Bell basis ⇒ 2 bits of info.\nIf channel is not perfect, performance gain is much higher than 2."},"Quantum-Information/Quantum-Computation/Algorithms/Bernstein-Vazirani-algorithm":{"slug":"Quantum-Information/Quantum-Computation/Algorithms/Bernstein-Vazirani-algorithm","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Algorithms/Bernstein-Vazirani algorithm.md","title":"Bernstein-Vazirani algorithm","links":["Quantum-Information/Quantum-Computation/Algorithms/Deutsch-Jozsa-algorithm"],"tags":[],"content":"Consider the functions:\nf_a(x) = x\\cdot a = \\mathrm{mod}_2\\left[\\sum _j x_ja_j\\right]\nThe Bernstein-Vazirani algorithm is a quantum algorithm capable of determining the target bit string a in just one interrogation. Classically, we would need n interrogations.\n\nThe functioning of this algorithm is basically the same as Deutsch-Jozsa algorithm’s. The output in A reads:\n\\sum _{x,y}\\frac{(-1)^{f_a(x)+x\\cdot y}\\ket{y}}{N}\nThis is exactly \\ket{a}, which is evident when projecting onto that vector."},"Quantum-Information/Quantum-Computation/Algorithms/Deutsch-Jozsa-algorithm":{"slug":"Quantum-Information/Quantum-Computation/Algorithms/Deutsch-Jozsa-algorithm","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Algorithms/Deutsch-Jozsa algorithm.md","title":"Deutsch-Jozsa algorithm","links":["Quantum-Information/Quantum-Computation/Function-Gate","Quantum-Information/Quantum-Computation/Hadamard-Gate","Quantum-Information/Foundations/Qubits","Quantum-Information/Quantum-Computation/Classical-Computation/Probabilistic-Turing-Machine-(PTM)"],"tags":[],"content":"Consider binary functions:\nf:\\{0,1\\}\\mapsto\\{0,1\\}\nthere are 4 possible functions of this type:\nf_1(x) = x\nf_2(x) = \\bar{x}\nf_3(x) = 0\nf_4(x) = 1\nf_1,f_2 are called balanced functions, while the other are called constant functions.\nConsider a situation where you are given a black box, which applies one of the four binary functions above. How many times do we need to apply the black box in order to understand whether the function inside is balanced or constant? Classically, we would need 2 interrogations, in the quantum case one is enough, through the Deutsch-Jozsa algorithm.\nImplementation\n\nWe use a Uf gate and a few Hadamard gates as seen in the picture. We are just interested in the A register, the B register can be discarded.\nThe the algorithm follows the steps below:\n\nInitialize qubits in \\ket{0}_A\\ket{1}_B\nApply Hadamard gates to both registries\nApply U_f gate, of which we want to find to which category the f belongs\nApply Hadamard gate to the A registry\nMeasurement\nThe induced transformation is:\n\n\\ket{0}_A\\ket{1}_B \\mapsto\\ket{+}_A\\ket{-}_B\\mapsto\\left(\\frac{(-1)^{f(0)}\\ket{0}_A+(-1)^{f(1)}\\ket{1}_A}{\\sqrt{2}}\\right)\\ket{-}_B \naside a global phase, in the A registry we find \\ket{+} if f is constant and \\ket{-} if f is balanced; applying the last Hadamard, we transform those two configurations, respectively, into \\ket{0}, \\ket{1}\nGeneralization\nFor boolean functions of the type:\nf:\\{0,1\\}^n\\mapsto\\{0,1\\}\nthe division balanced/constant functions is not exhaustive (some functions are neither). There are\nN=\\left(\\begin{array}{c}2^n\\\\2^{n-1}\\end{array}\\right)\nbalanced functions (list all inputs, which are 2^n, all balanced functions are obtained from permutations of the output of a single balance function, which has 2^n/2 1’s and 2^n/2 0’s). If we know that either a constant or balanced function is selected, classically, we would need\n\\frac{N}{2} +1 \\sim \\exp (n)\ninterrogations; in the quantum case just one interrogation is enough.\nAlgorithm\n\nThe algorithm works the same way as the standard one, substituting Hadamard gates with global Hadamard gates in the A registry.\nThe final measurement is a projective measurement onto \\ket{0}_A^{\\otimes n}. Given \\Omega = 2^n:\n\\ket{+}\\equiv \\sum_x\\frac{\\ket{x}}{\\sqrt{\\Omega}}\n\\ket{0}_A ^{\\otimes n}\\ket{1}_B\\mapsto\\ket{+}_A\\ket{-}_B\\mapsto \\frac{1}{\\Omega}\\sum_{x,y}(-1)^{f(x)+x\\cdot y}\\ket{y}_A\nThe probability of getting \\ket{0}^{\\otimes n}_A as the output in A is\n\\abs{\\frac{\\sum_x(-1)^{f(x)}}{\\Omega}}^2\nTherefore, if f is constant, the probability is 1, while if f is balanced, the probability is 0. This is not proof of quantum advantage because a Probabilistic Turing Machine (PTM) is able to solve this problem in poly(n), not \\exp (n). The kind of reduction in complexity that we are looking for in order to claim quantum advantage is exponential to polynomial."},"Quantum-Information/Quantum-Computation/Algorithms/Factoring-algorithm-(Shor's-algorithm)":{"slug":"Quantum-Information/Quantum-Computation/Algorithms/Factoring-algorithm-(Shor's-algorithm)","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Algorithms/Factoring algorithm (Shor's algorithm).md","title":"Factoring algorithm (Shor's algorithm)","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Computational-complexity-classes","Quantum-Information/Quantum-Computation/Algorithms/Quantum-order-finding-algorithm","Quantum-Information/Quantum-Computation/Algorithms/Period-finding"],"tags":[],"content":"Problem\nGiven a big integer N such that its prime composition is:\nN = p_1p_2,\nwhere p_1, p_2 are primes. We want to find these primes. Classically, this problem has a complexity of \\exp (n^{1/3}\\log ^{2/3} n), where N\\sim 2^n.\nUsing a quantum algorithm, which exploits period finding, this problem can be solved in \\mathrm{poly}(n).\nClassically, the best strategy consist in the random extraction of an integer M; two possible outcomes:\n\nM,N share a divisor: in this case, finding the primes is easy\nM,N are coprime, here classically we can do nothing, while in the quantum case M can be used to generate a new number, which will be useful for finding the primes.\n\nModular exponential\nThis is related to the order. Consider two integers N,M; define:\nf_M(a) = \\mod{N}{M^a}\nwhere a\\in\\{0,1,...,N-1\\}; note that f_M(0) =1. f_M is periodic, let us call the period r the smallest integer &gt;0 such that.\nf_M(r) = 1\nFinding r in this problem specifically is called order finding. The Period finding algorithm allows us to find it easily.\nAlgorithm\n\nExtract M\nFind the period r of f_M(a), so that \\mod{N}{M^r -1}= 0\nIf r is odd, go back to step 1. If r is even, then, by definition\n\\left(M^{r/2} -1\\right)\\left(M^{r/2} +1\\right)= kN\nfor some k integer. Call M^{r/2} -1 \\equiv M_1 and M^{r/2} +1\\equiv M_2. Now, we have two possible situations:\n\nEither M_1 or M_2 are individually proportional to N, meaning M_{1(2)} = k&#039; p_1p_2. This does not tell us anything, restart algorithm\nIf the case above does not apply, suppose without loss of generality that M_1\\propto p_1 and M_2 \\propto p_2. Now either of those numbers can be used in the classical algorithm (Compute GCD).\n\n\n"},"Quantum-Information/Quantum-Computation/Algorithms/Grover-algorithm":{"slug":"Quantum-Information/Quantum-Computation/Algorithms/Grover-algorithm","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Algorithms/Grover algorithm.md","title":"Grover algorithm","links":["Quantum-Information/Quantum-Computation/Algorithms/Quantum-algorithms","Quantum-Information/Quantum-Computation/Computational-basis","Quantum-Information/Quantum-Computation/Hadamard-Gate"],"tags":[],"content":"The Grover algorithm solves a data search problem. The quantum advantage is not of the type\n\\exp(n)\\mapsto\\mathrm{poly}(n)\n(see Quantum algorithms) but it’s still there\nProblem\nSuppose we have an unstructured database with N entries N = 2^n and we want to find an integer x_0 in this database. We have an oracle which tells us if an extraction is the correct one:\nf(x) = \\left\\{\\begin{array}{l}0 \\quad x\\neq x_0\\\\ 1 \\quad x = x_0\\end{array}\\right.\nHow many interrogations are needed to find x_0 with good probability? Classically, o(2^n). Using the quantum Grover algorithm, this becomes o(2^{n/2}).\nAlgorithm\n\nFrom now on, use vector binary notation (see Computational basis). Define a Grover gate which behaves more or less like the oracle:\nG\\ket{\\vec{x}} = \\left\\{\\begin{array}{l}\\ket{\\vec{x}} \\quad x\\neq x_0\\\\ -\\ket{\\vec{x}} \\quad x = x_0\\end{array}\\right.\nThese gates present the structure depicted above, where f is the oracle.\nNote that G is a unitary and\nG = \\mathrm{Id} -2\\op{\\vec{x}_0}{\\vec{x}_0}\nThis unitary can be generalized for any target state:\nD_v \\equiv \\mathrm{Id} -2\\op{v}{v}\nso that \\ket{v} \\mapsto -\\ket{v} and \\ket{v_\\perp} \\mapsto\\ket{v_\\perp}. Take \\ket{v} to be \\ket{s}, the superposition of all the elements of the computational basis:\n\\ket{s}\\equiv \\sum_{\\vec{x}}\\frac{\\ket{\\vec{x}}}{\\sqrt{N}} = H \\ket{0}\nwhere H is the global Hadamard.\nD_s \\equiv D\nWe want to build the gate associated to D. Take G_0\\equiv\\mathrm{Id} -2\\op{\\vec{0}}{\\vec{0}}, then:\nD = H^{\\otimes n} G_0 H^{\\otimes n}\nNow we only need to build G_0, as seen in the picture below, the rest is easy.\n\nThe main feature of the algorithm consists in applying a sequence of DG gates to an initial state \\ket{s} a number of times of order \\sqrt{N}. When doing this, we can prove that the probability of getting \\ket{\\vec{x}_0} at the end is close to 1.\nConsider the state\n\\ket{r} = \\sum_{x\\neq x_0} \\frac{\\ket{\\vec{x}}}{\\sqrt{N-1}}\nand note that\n\\ket{s} = \\sqrt{\\frac{N-1}{N}}\\ket{r}+\\frac{1}{\\sqrt{N}}\\ket{\\vec{x}_0}\nNow, take \\ket{r},\\ket{\\vec{x}_0}; these two states are orthogonal:\n\\ip{r}{\\vec{x}_0} =0\nConsider the 2-dimensional Hilbert space spanned by them:\n\\mathcal{H}_G \\equiv \\mathrm{span}\\left\\{\\ket{r},\\ket{\\vec{x}_0}\\right\\}\nObviously:\n\\ket{s}\\in\\mathcal{H}_G\nIt turns out that \\mathcal{H}_G is an eigenspace of D and G. For G this is trivial, while for D, it sends \\ket{s}\\mapsto-\\ket{s} while \\ket{s ^\\perp}\\mapsto\\ket{s^\\perp}.\nWe apply DG K times:\n(DG)^K\\ket{s}\\in\\mathcal{H}_G\nUsing a representation where \\ket{r} is the y vector and \\ket{\\vec{x}_0} is the x vector, DG in matrix form becomes:\nDG \\sim \\begin{pmatrix}1-\\frac{2}{N} &amp; -2\\frac{\\sqrt{N-1}}{N}\\\\ 2\\frac{\\sqrt{N-1}}{N} &amp; 1-\\frac{2}{N}\\end{pmatrix}\nwhich is clearly a rotation in \\mathcal{H}_G:\n\\sin \\theta \\equiv 2\\frac{\\sqrt{N-1}}{N}\nFor large N:\n\\theta \\sim \\frac{2}{\\sqrt{N}}\nSince the angle between \\ket{s} and \\ket{r} is very small, approximately we need to apply this transformation as many times K as it takes in order to have:\nK\\sim \\pi/(2\\theta)\\sim\\sqrt{N}\nIt is possible to prove that this is the best we can do in the quantum case."},"Quantum-Information/Quantum-Computation/Algorithms/Period-finding":{"slug":"Quantum-Information/Quantum-Computation/Algorithms/Period-finding","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Algorithms/Period finding.md","title":"Period finding","links":["Quantum-Information/Quantum-Computation/Algorithms/Quantum-Fourier-Transform-(QFT)","Quantum-Information/Quantum-Computation/Computational-basis"],"tags":[],"content":"We can use the Quantum Fourier Transform (QFT) to find the period of a function in a polynomial number of steps:\nf:\\{0,1\\}^n\\mapsto \\{0,1\\}^m\nf\\left(\\mod{2^n}{x+r}\\right) = f(x) \\qquad \\forall \\vec{x}\nwhere {r}, 0&lt; r&lt; N-1, is the smallest period, which we want to find, and we are working in the Computational basis switching from binary form to integers:\nx= x_0 2^0 + ... +x_{n-1}2^{n-1}\nFor the sake of simplicity we will make a number of assumptions:\n\nr is a divisor of N=2^n, which means r=2^t and t\\leq \\log _2 N = n.\nNo accidental periodicity\nBasically, we are restricting ourselves to functions that are monotonous at fixed intervals:\n\n\nImplementation\nThe first step in the procedure goes as illustrated below:\n\nPerforming the measurement on B before or after the QFT on A is equivalent, so it’s usually convenient to perform the measurement first.\nWe can rewrite the state before the QFT as a superposition based on the state in the B registry, so that we can group together states associated to the same value of f; performing the measurement on B first, and supposing the outcome is f(x&#039;), 0 \\leq x&#039; \\leq r-1, then the state before the QFT is:\n\\frac{\\sum _{k=0} ^{N/r -1} \\ket{x&#039;+kr}_A\\ket{f(x&#039;)}_B}{\\sqrt{N/r}}\nObtaining a specific value f(x&#039;) has probability 1/r (uniform distribution). Now discard the B registry, applying the QFT on A returns:\n\\ket{\\psi}_A = \\sqrt{\\frac{r}{N}}\\sum _{k=0} ^{N/r -1} \\frac{1}{\\sqrt{N}} \\sum _{y=0} ^{N-1} e^{2\\pi i y (x&#039;+kr)/N}\\ket{y}_A\nIt is useful to note here that:\n\\sum _{k=0} ^{N/r-1} e^{2\\pi i y kr/N}=\\left\\{\\begin{array}{ll}0 &amp;\\quad\\forall y\\neq lN/r, \\,l\\in\\mathbb{N}\\\\ N/r &amp;\\quad\\forall y = lN/r, \\,l\\in\\mathbb{N}\\end{array}\\right.\nSo that only some y‘s survive the sum, with the maximum possible value being y=N\n\\ket{\\psi}_A= \\frac{1}{\\sqrt{r}}\\sum _{l=0} ^{r-1} e^{2\\pi i y x&#039;/N}\\ket{y}_A\\delta (y-lN/r)\nIf we repeat the protocol a few times and measure the A register, we find a list of y_i:\ny_i = l_i N/r\nN/y_i = r/l_i\nIn \\mathrm{poly}(n) repetitions, there exists an efficient classical algorithm for finding r from the r/l_i fractions. Broadly speaking, what we need to do is the following:\n\nFor each N,y_i, compute the greatest common divisor, with an existing efficient algorithm \\rightarrow GCD(N,y_i) \\equiv G_i, so that\nN= q_i G_i\\qquad y_i = q&#039;_i G_i\nwhere q_i,q&#039;_i are coprime\nHere we have\nN/y_i = q_i/q&#039;_i = r/l_i\nWe have two possibility:\n\nr=q_i, l_i=q&#039;_i, which means that r,l_i are coprime\nr is a multiple of q_i, and so r and l_i share a divisor. This means that q_i is a lower bound for r\n\n\nEstimate:\n\\tilde{r} = \\max \\{q_i\\}\nwhat is the probability that \\tilde{r} = r? Once y_i is extracted, the q_i,q&#039;_i are fixed and so is l_i. The probability that \\tilde{r} = r is equivalent to the probability of extracting a y_i such that l_i and r are coprime after k repetitions. Since extracting y_i follows a flat distribution, the problem is equivalent to randomly extracting a number between 0 and r and hoping for it to be coprime with r. After k extractions, we get a lower bound\n"},"Quantum-Information/Quantum-Computation/Algorithms/Quantum-Fourier-Transform-(QFT)":{"slug":"Quantum-Information/Quantum-Computation/Algorithms/Quantum-Fourier-Transform-(QFT)","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Algorithms/Quantum Fourier Transform (QFT).md","title":"Quantum Fourier Transform (QFT)","links":["Quantum-Information/Foundations/Qubits","Quantum-Information/Quantum-Computation/Computational-basis","Quantum-Information/Quantum-Computation/Hadamard-Gate","Quantum-Information/Quantum-Computation/Controlled-unitaries","Quantum-Information/Quantum-Computation/Swap-gates","Quantum-Information/Quantum-Computation/Classical-Computation/Computational-complexity-classes"],"tags":[],"content":"Setting\nConsider n Qubits, we label the elements of the computational basis using an integer x\\in [0,2^n -1], and 2^n \\equiv N. In the Computational basis:\n\\ket{x_{n-1},...,x_0}\\in\\mathcal{H}_2 ^{\\otimes n}\nx= x_0 2^0 + ... +x_{n-1}2^{n-1}\nThe basis we are working with is:\n\\left\\{\\ket{0},\\ket{1},...,\\ket{N-1}\\right\\}\n\\ip{\\tilde{x}}{\\tilde{x}^\\prime}=\\delta_{x,x^\\prime}\nDefinition\nThe quantum discrete Fourier transform is defined as a gate such that:\nU_{qft}\\ket{x}=\\ket{\\tilde{x}}=\\frac{1}{\\sqrt{N}}\\sum_{y=0}^{N-1}e^{i2\\pi x y/N}\\ket{y}\nEmploying the orthonormality relation:\nU_{qft} = \\sum _{x=0}^{N-1}\\op{\\tilde{x}}{x}= \\frac{1}{\\sqrt{N}}\\sum_{x,y=0}^{N-1}e^{i2\\pi xy/N}\\op{y}{x}\nOur goal is to show that this gate is implementable with polynomial complexity.\nLet’s cast everything in a more useful form first, define:\n\\omega \\equiv e^{i2\\pi/N}\nso that:\nU_{qft} =  \\frac{1}{\\sqrt{N}}\\sum_{x,y=0}^{N-1}\\omega^{xy}\\op{y}{x}\nNote that if the input is \\ket{0}, this gate reduces to the global Hadamard gate.\n\\ket{\\tilde{0}}=  \\frac{1}{\\sqrt{N}}\\sum_{x=0}^{N-1}\\ket{x}=H\\ket{0}\nThe Hadamard gate is built up of local unitaries, while in general the QFT gate requires qubit interactions.\nSeparability\nIt can be proven that:\n\\ket{\\tilde{x}}\\textrm{ is separable } \\forall x\nthat is, the gate does not generate entanglement for the elements of the basis we are considering. We try to prove this:\n\\ket{\\tilde{x}} =  \\frac{1}{\\sqrt{N}}\\sum_{y=0}^{N-1}\\omega^{xy}\\ket{y}\\overset{\\textrm{binary form}}{=}\\frac{1}{\\sqrt{N}}\\sum_{\\vec{y}}\\omega^{x\\left(\\sum _{l=0}^{n-1}2^l y_l\\right)}\\ket{\\vec{y}}\n\\ket{\\vec{y}} = \\ket{y_0,...,y_{n-1}}\\quad y = \\sum _{l=0}^{n-1}2^l y_l\n\\ket{\\tilde{x}}=\\frac{1}{\\sqrt{N}}\\sum_{y_0,...,y_{n-1}}\\prod_{l=0}^{n-1}\\omega^{x\\left(2^l y_l\\right)}\\ket{y_0,...,y_{n-1}}=\\frac{1}{\\sqrt{N}}\\sum_{y_0,...,y_{n-1}}\\ket{\\hat{y}_0,...,\\hat{y}_{n-1}}\n\\ket{\\hat{y}_l} \\equiv \\omega^{x 2^l y_l}\\ket{y_l}\nIndeed the output (for inputs in our selected basis) is still separable. The sum can be separated, leading to a tensor product state. Expanding the sum:\n\\ket{\\tilde{x}} = \\bigotimes _{l=0}^{n-1}\\frac{\\ket{0}_l+e^{i2\\pi x/2^{n-l}}\\ket{1}_l}{\\sqrt{2}}\\equiv\\bigotimes _{l=0}^{n-1}\\ket{\\tilde{x}_l}_l\nImplementation\nConsider the relative phase between 0 and 1 in each subspace of \\ket{\\tilde{x}} in the form above:\ne^{i2\\pi x/2^{n-l}} =e^{\\frac{i2\\pi}{2^{n-l}} \\left(x_0 2^0 + ... +x_{n-1}2^{n-1}\\right)}\nFocus on l=n-1, in this case each x_k term with associated coefficient 2^{k} yields a phase of 1 if k\\geq 1, so they have no contribution. Iterating this procedure, we can see that the relative phase in the k-th transformed qubit depends on x_0,...,x_{n-1-k}, k=0,...,n-1.\nTherefore, the first building block of the QFT acts on the qubit n-1, and transforms it into the \\ket{\\tilde{x}_0}, which does not have a contribution on the other qubits.\n\nWith the Controlled unitaries acting through the matrix:\nR_j \\equiv \\begin{pmatrix}1 &amp;0 \\\\ 0 &amp; e^{2\\pi i/2^j}\\end{pmatrix}\nThe (n-1)-th qubit is already done, we need to perform operations on the remaining qubits. The gate sequence above will be called B_{n-1}; more specifically:\n\nNow we just need to apply a sequence of these gates:\n\nApplying a SWAP sequence yields the QFT. We have \\sim n B blocks, each containing \\sim n c-unitaries, so that the computational cost of the algorithm is O(n^2). Classically, this algorithm requires \\sim\\exp n.\nIt’s easy to show that the QFT gate, in general, generates entanglement. In the 2 qubits case:\n\\left(\\ket{0}_0\\otimes\\frac{\\ket{0}_1+e ^{i\\phi}\\ket{1}_1}{\\sqrt{2}}\\right)\\overset{QFT}{\\mapsto}\\textrm{ entangled state}"},"Quantum-Information/Quantum-Computation/Algorithms/Quantum-algorithms":{"slug":"Quantum-Information/Quantum-Computation/Algorithms/Quantum-algorithms","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Algorithms/Quantum algorithms.md","title":"Quantum algorithms","links":["Quantum-Information/Quantum-Computation/Quantum-computation","Quantum-Information/Quantum-Computation/Classical-Computation/Classical-computation","Quantum-Information/Quantum-Computation/Classical-Computation/Computational-complexity-classes","Quantum-Information/Quantum-Computation/Algorithms/Deutsch-Jozsa-algorithm","Quantum-Information/Quantum-Computation/Algorithms/Bernstein-Vazirani-algorithm","Quantum-Information/Quantum-Computation/Algorithms/Simon-algorithm","Quantum-Information/Quantum-Computation/Algorithms/Quantum-Fourier-Transform-(QFT)","Quantum-Information/Quantum-Computation/Algorithms/Quantum-order-finding-algorithm","Quantum-Information/Quantum-Computation/Algorithms/Period-finding","Quantum-Information/Quantum-Computation/Algorithms/Factoring-algorithm-(Shor's-algorithm)","Quantum-Information/Quantum-Computation/Algorithms/Grover-algorithm"],"tags":[],"content":"Using Quantum computation, we can build algorithms capable of solving problems much faster then Classical computation algorithms. The kind of improvement we are looking for is:\n\\exp(n)\\mapsto\\mathrm{poly}(n)\nsee Computational complexity classes.\nSome notable quantum algorithms include:\n\nDeutsch-Jozsa algorithm\nBernstein-Vazirani algorithm\nSimon algorithm\nQuantum Fourier Transform (QFT)\nQuantum order finding algorithm\nPeriod finding\nFactoring algorithm (Shor’s algorithm)\nGrover algorithm\n"},"Quantum-Information/Quantum-Computation/Algorithms/Quantum-order-finding-algorithm":{"slug":"Quantum-Information/Quantum-Computation/Algorithms/Quantum-order-finding-algorithm","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Algorithms/Quantum order finding algorithm.md","title":"Quantum order finding algorithm","links":[],"tags":[],"content":"Order definition\nTake two positive integers x, N with no common factors. The order of x modulo N is the least positive integer r such that:\n\\mod{N}{x^r} = 1"},"Quantum-Information/Quantum-Computation/Algorithms/Simon-algorithm":{"slug":"Quantum-Information/Quantum-Computation/Algorithms/Simon-algorithm","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Algorithms/Simon algorithm.md","title":"Simon algorithm","links":["Quantum-Information/Quantum-Computation/Hadamard-Gate","Quantum-Information/Quantum-Computation/Function-Gate"],"tags":[],"content":"Consider the function:\nf_b:\\{0,1\\}^n\\mapsto\\{0,1\\}^n\nwhere b is not the null string, such that it presents a kind of periodicity:\nf_b(x) =f_b(y)\\Leftrightarrow x=y\\oplus b\nMeaning that the inputs can be grouped into couples that share the same output.\nAlgorithm\nIf we find two inputs belonging to the same output class, it’s easy to find b, as we can just XOR sum them.\nClassically, we need to do a random search on the inputs, which has complexity \\exp(n).\nIn the quantum case:\n\n\nWe have two registers A and B, containing n qubits each, initialized in \\ket{0}^{\\otimes n}_A\\ket{0}^{\\otimes n}_B\nApply a global Hadamard gate on A\nApply a Uf gate on A and B\nApply a global Hadamard gate on A\nMeasure everything\nAfter the U_f gate, the state reads:\n\n\\sum_x\\frac{\\ket{x}_A\\ket{f_b(x)}_B}{\\sqrt{N}}\nThe last Hadamard on A and the measurement on B commute.\nWe perform the measurement first, so if we label the output classes in B f_j, for each f_j we would have two states in A corresponding to the input associated to f_j, i.e. \\ket{x_{f_j}}_A,\\ket{x_{f_j}\\oplus b}_A. Before the measurement:\n\\frac{1}{\\sqrt{N/2}}\\sum _{j}\\left(\\frac{\\ket{x_{f_j}}_A+\\ket{x_{f_j}\\oplus b}_A}{\\sqrt{2}}\\ket{f_j}_B\\right)\nSo when we perform a projective measurement onto \\ket{f_j}_B, each output is equiprobable with probability 2/N.\nAfter the measurement, on registry A:\n\\frac{\\ket{x_{f_j}}+\\ket{x_{f_j}\\oplus b}}{\\sqrt{2}}\nWe apply the Hadamard:\n\\frac{\\ket{x_{f_j}}+\\ket{x_{f_j}\\oplus b}}{\\sqrt{2}}\\mapsto \\frac{1}{\\sqrt{2}}\\frac{C}{\\sqrt{N}}\\sum _y (-1)^{x_{f_j}\\cdot y}\\left(1+(-1)^{b\\cdot y}\\right)\\ket{y}\nwhere C is a normalization constant (possibly 1 but not sure and it’s not important to the functioning of the algorithm). The only remaining states y in the output of A are those orthogonal to b:\ny\\cdot b =0\nIf we run the protocol k times, it’s very unlikely to extract the same y, therefore after k runs of the protocol we have k different values of y all orthogonal to b. This induces a set of k linear equations.\n\\left\\{\\begin{array}{l}b\\cdot y_1 =0\\\\ b\\cdot y_2 =0\\\\ \\vdots\\\\ b\\cdot y_k =0\\end{array}\\right.\nWhich k is enough to find b? It scales \\sim O(n)."},"Quantum-Information/Quantum-Computation/CNOT-gate":{"slug":"Quantum-Information/Quantum-Computation/CNOT-gate","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/CNOT gate.md","title":"CNOT gate","links":["Quantum-Information/Quantum-Computation/Controlled-gates","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Entanglement/Entangled-states","Quantum-Information/Entanglement/Bell-states","Quantum-Information/Quantum-Computation/Computational-basis","Quantum-Information/Quantum-Computation/One-qubit-gates","Quantum-Information/Quantum-Computation/Controlled-unitaries","Quantum-Information/Quantum-Computation/Swap-gates"],"tags":[],"content":"\nThe CNOT gate is a controlled gate which induces the X transformation (NOT, see Pauli operators) on one qubit when the other is in the \\ket{1} state:\nCNOT\\ket{0}_A\\ket{\\psi}_B = \\ket{0}_A\\ket{\\psi}_B\nCNOT\\ket{1}_A\\ket{\\psi}_B = \\ket{1}_AX_B\\ket{\\psi}_B\nCNOT gates generate entanglement and they can be used to generate Bell states.\nOn elements of the Computational basis:\n\\ket{x_0}_A\\ket{x_1}_B \\overset{CNOT}{\\mapsto} \\ket{x_0}_A\\ket{x_0\\oplus x_1}_B\nApparent asymmetry\nThere is an apparent asymmetry inherent to the CNOT, which is solved by looking at the gate’s action upon +,-:\nCNOT \\ket{\\pm }_A\\ket{+}_B=\\ket{\\pm }_A\\ket{+}_B\nCNOT\\ket{\\pm }_A\\ket{-}_B = \\ket{\\mp }_A\\ket{-}_B\nThe CNOT applied on the basis of X induces a transformation on the “controlling” qubit. This is further exacerbated when applying Hadamard gates before and after the CNOT:\n\nOperations built from CNOT\nUsing CNOT gates and One qubit gates, a number of operations can be constructed:\n\nControlled unitaries\nSwap gates\n"},"Quantum-Information/Quantum-Computation/Classical-Computation/Church-Turing-Thesis":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Church-Turing-Thesis","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Church-Turing Thesis.md","title":"Church-Turing Thesis","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Turing-machine","Quantum-Information/Quantum-Computation/Quantum-computation","Quantum-Information/Quantum-Computation/Classical-Computation/Probabilistic-Turing-Machine-(PTM)"],"tags":[],"content":"If a function f is computable in any computational model, then there exist a Turing machine that can compute f.\nThis means that the notion of computability by a Turing machine is the fundamental one.\nQuantum computation obeys the CT thesis (functions that are not computable by a Turing machine remain not computable by a quantum computer).\nStrong Church-Turing Thesis\nStatement:\nAny model of computation can be simulated by a Probabilistic Turing Machine (PTM) within a computational time that is polynomial in the computational time of the original model.\nQuantum computation may break the SCT thesis."},"Quantum-Information/Quantum-Computation/Classical-Computation/Classical-computation":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Classical-computation","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Classical computation.md","title":"Classical computation","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Turing-machine","Quantum-Information/Quantum-Computation/Classical-Computation/Gate-array-model-(classical)"],"tags":[],"content":"Models\nThere exists two main models for classical computation\n\nTuring machine model\nGate array model (classical)\n"},"Quantum-Information/Quantum-Computation/Classical-Computation/Computational-complexity-classes":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Computational-complexity-classes","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Computational complexity classes.md","title":"Computational complexity classes","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Turing-machine","Quantum-Information/Quantum-Computation/Classical-Computation/Gate-array-model-(classical)","Quantum-Information/Quantum-Computation/Classical-Computation/Probabilistic-Turing-Machine-(PTM)","Quantum-Information/Quantum-Computation/Quantum-computation","Quantum-Information/Quantum-Computation/Algorithms/Factoring-algorithm-(Shor's-algorithm)","Quantum-Information/Quantum-Computation/Classical-Computation/Church-Turing-Thesis","Quantum-Information/Quantum-Computation/Classical-Computation/NP-complete-problems"],"tags":[],"content":"\nIn the following, by t_{M}(x) we denote the time it takes for a Turing machine M to solve a given problem, and by n we denote the number of digits needed to express the input x.\nDecision problems\nDecision problems (basically binary functions, see Gate array model (classical)) are used to categorize the computational complexity of a given problem\nTerminology\n\nLanguage: a language L is a subset of an alphabet \\Gamma whose elements are all finite\nA language L is decided by a Turing machine M if\n\nM(x) = 0,1 \\quad\\forall x\\in L\n\nFor a decided language L by the machine M,\n\nx\\in L \\Rightarrow M(x) =1 \n$$meaning that $x$ is **accepted** by $M$\n- For a decided language $L$ by the machine $M$,\nx\\notin L \\Rightarrow M(x) =0\n$$meaning that x is rejected by M\nP class\nPoly time\nA problem f belongs to the P class if \\exists M: t_M(x) = \\mathrm{poly}(n).\nBPP class\nBounded-error Probabilistic Polynomial time\nGiven a language L, L\\in BPP if there exists a Probabilistic Turing Machine (PTM) PM such that\nx\\in L \\Rightarrow PM (x) =1 \\quad\\textrm{at least 50\\% of the time}\nBQP class\nBounded-error Quantum Polynomial time\nQuantum equivalent of the BPP class. Factoring problem belongs in BQP for now, as no classical algorithm exists to solve this problem in poly time. If factoring is in BQP but not in BPP, then the SCT thesis is false.\nNP class\nNon deterministic Poly time\nA problem f belongs to the NP class if \\nexists M: t_M(x) = \\mathrm{poly}(n).\nHowever, once M(x) has been produced, it is easy (P class) to check whether\nM(x) = f(x)\nFor sure, \\mathrm{NP}\\supseteq\\mathrm{P}, however, a big issue here is\n\\mathrm{NP}\\overset{?}{=}\\mathrm{P}\nNo one knows.\nMore precisely, suppose a language L\\in NP, then \\exists M such that:\n\nIf x\\in L then \\exists w: M(x,w) = 1 in poly time\nIf x\\notin L then \\forall w, M(x,w) = 0 in poly time\nAll NP problems can be mapped into NP complete problems in poly time.\n"},"Quantum-Information/Quantum-Computation/Classical-Computation/Gate-array-model-(classical)":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Gate-array-model-(classical)","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Gate array model (classical).md","title":"Gate array model (classical)","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Turing-machine","Quantum-Information/Quantum-Computation/Classical-Computation/Universal-Gate-sets"],"tags":[],"content":"\nThe gate array model is equivalent to the Turing machine model, i.e. one can be mapped into the other in poly time\nThe model works by encoding the input into strings of bits, so that any function we may want to compute reduces to a binary function:\nx\\in\\{0,1\\}^{n}\\quad f(x)\\in \\{0,1\\}^{m}\nThe universality of the gate array model is guaranteed through the existence of Universal Gate sets"},"Quantum-Information/Quantum-Computation/Classical-Computation/Halting-problem":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Halting-problem","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Halting problem.md","title":"Halting problem","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Church-Turing-Thesis","Quantum-Information/Quantum-Computation/Classical-Computation/Turing-machine"],"tags":[],"content":"The halting problem is a not computable problem (see Church-Turing Thesis)\nFor a given Turing machine M, identified by the Turing number T_M, for a given input \\vec{x}, one of two things can happen: either the machine reaches the end of the computation or it does not. We want to build a Turing machine capable of predicting which of these two outcomes will happen:\nH(T_M,\\vec{x}) = \\left\\{\\begin{array}{l}0\\quad \\textrm{if } M\\textrm{ does not halt with input }\\vec{x}\\\\ 1\\quad \\textrm{if } M\\textrm{ halts with input }\\vec{x}\\end{array}\\right.\nBut, if such a machine existed, a new one called IM could be built that works as follows:\n\nTake an input \\vec{x}\nAssign y = H(T_{IM},\\vec{x})\nIf y=0 then halt\nIf y=1, then loop forever\nThis machine is self-contradictory, so H cannot exist\n"},"Quantum-Information/Quantum-Computation/Classical-Computation/Hamming-Distance":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Hamming-Distance","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Hamming Distance.md","title":"Hamming Distance","links":[],"tags":[],"content":"\nGiven two bit strings, their Hamming distance is the total amount of different bits between the two strings\nIn the figure, a new set of strings, at Hamming distance one, is generated by changing the value of the left-most string in the original set."},"Quantum-Information/Quantum-Computation/Classical-Computation/Landauer-Principle":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Landauer-Principle","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Landauer Principle.md","title":"Landauer Principle","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Classical-computation","Quantum-Information/Quantum-Computation/Classical-Computation/Toffoli-gate"],"tags":[],"content":"Is logical irreversibility necessary for Classical computation?\nThe Landauer principle is in a one to one relationship with the second principle of thermodynamics.\nConnection between physics and information theory; suppose there is a machine performing operation in equilibrium with a thermal bath.\n\nSuppose we perform a logically irreversible operation, e.g. erase a bit of information; this costs a certain amount of heat:\n\\Delta Q \\geq k_B T\\log 2\nWe might ask ourselves whether classical computation is only possible if we assume logical irreversibility.\nThe Toffoli gate is universal and reversible, so the answer is NO, however, what requires dissipation is the erasure of memory"},"Quantum-Information/Quantum-Computation/Classical-Computation/Maxwell-paradox":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Maxwell-paradox","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Maxwell paradox.md","title":"Maxwell paradox","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Landauer-Principle"],"tags":[],"content":"\nThe Maxwell paradox provides a rudimentary proof for the Landauer Principle.\nRules of the game: we have a chamber with two internal rooms submerged in a thermal bath at temperature T, see figure. The right wall is frictionless, same as a door between the two rooms.\nThe Maxwell paradox is a protocol that allows to extract work from the “thermal machine” described in the previous configuration, which is thermodinamically impossible (single thermal bath): there is a “demon” capable of controlling the middle door, which they open when and only when they see a particle moving from right to left, so that they can map whichever starting configuration to the 0 configuration with apparently 0 work. Afterwards, attach middle wall to mechanical engine (e.g. pulley) and let the gas expand ⇒ free energy. However, this process is not a cycle, the demon has acquired memory, which they need to erase ⇒ Landauer principle compensates the energy “produced”."},"Quantum-Information/Quantum-Computation/Classical-Computation/NP-complete-problems":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/NP-complete-problems","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/NP complete problems.md","title":"NP complete problems","links":[],"tags":[],"content":""},"Quantum-Information/Quantum-Computation/Classical-Computation/Probabilistic-Turing-Machine-(PTM)":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Probabilistic-Turing-Machine-(PTM)","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Probabilistic Turing Machine (PTM).md","title":"Probabilistic Turing Machine (PTM)","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Turing-machine"],"tags":[],"content":"A PTM is a regular Turing machine that integrates a random number generator (RNG), so that steps in the computational process can be decided following a probability distribution.\nBy construction\nPTM \\supseteq TM\nWe say that a function f is computable by a PTM if for every input \\vec{x}, we have\nPM(\\vec{x}) = f(\\vec{x})\nwith probability of at least 1/2, so that the computation can be repeated many times to increase the probability."},"Quantum-Information/Quantum-Computation/Classical-Computation/Toffoli-gate":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Toffoli-gate","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Toffoli gate.md","title":"Toffoli gate","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Universal-Gate-sets","Quantum-Information/Quantum-Computation/Classical-Computation/Classical-computation","Quantum-Information/Quantum-Computation/Controlled-gates"],"tags":[],"content":"\nThe Toffoli gate forms by itself a universal set for Classical computation. It is basically a NOT gate controlled by the value of two external bits (see Controlled gates).\nThe operation induced by this gate is logically reversible."},"Quantum-Information/Quantum-Computation/Classical-Computation/Turing-machine":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Turing-machine","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Turing machine.md","title":"Turing machine","links":[],"tags":[],"content":"\nA Turing machine contains 4 main elements:\n\nProgram, the set of internal instructions\nFinite state control, the set of internal states of the machine, denoted by\nq_1,...,q_m\nwhere m can be considered a constant without loss of generality. In addition to these states, there are also q_s,q_h, the starting and halting states respectively. q_s is the state of the machine at the start of the computation, during which the state will be altered; the computation will reach its end if and when the state of the machine becomes q_h.\nTape, which acts like the memory of a computer and is represented by a one dimensional object whose entries form an “alphabet”, which is the finite set of symbols. The alphabet can be whatever, but it is convenient to take the sample alphabet \\Gamma =\\left\\{0,1,\\mathrm{NULL},\\triangleright\\right\\}. \\triangleright marks the starting entry of the tape (think of the left-most entry). Initially, the tape will contain the \\triangleright symbol, a finite number of 0,1’s, and the rest of the tape will present NULL entries.\nRead-write tape-head, pointing to the position of the tape that is currently readable or writable.\nThe program is a finite ordered list of program lines, which take the form\n\n\\langle q,x,q&#039;,x&#039;,s\\rangle\n\nq is the state the machine must be in for the line to be executed\nx is the symbol that needs to be read by the tape-head for the line to be executed; all the non NULL entries form an array \\vec{x}.\nThe program searches its program lines in order to find a line that can be executed; if no such lines are found, q \\mapsto q_h.\nAfter executing a line, the state of the machine is changed to q&#039; and x is overwritten to x&#039;\nThe tape-head moves left, right or stands still depending on s = \\pm 1,0.\nThe output of the program is composed of the non NULL entries in the tape\nA function f is said to be computable by a Turing machine if there exists a Turing machine that, for any input \\vec{x}, reaches q_h in finite time and the final output on the tape reads f(\\vec{x}).\n"},"Quantum-Information/Quantum-Computation/Classical-Computation/Universal-Gate-sets":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Universal-Gate-sets","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Universal Gate sets.md","title":"Universal Gate sets","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Turing-machine"],"tags":[],"content":"A universal gate set is composed of gates whose combinations can compute any computable function (see Turing machine)\nAn example of universal set of gates is\n\\{AND,OR,COPY,NOT\\}\nAny function f can be expressed by a collection of functions:\nf:\\{0,1\\}^{n}\\mapsto\\{0,1\\}^{m}\nf(x) = \\left(f_1 (x),f_2 (x) ,...,f_m(x) \\right)\nf_j : \\{0,1\\}^{n}\\mapsto\\{0,1\\}\nThis is possible thanks to the feasibility of the COPY operation, see picture below\n\nWhat kind of functions are the f_j‘s? They are sort of characteristic functions, we can define the supports of the inputs leading to the outputs 0,1:\nS_0 \\equiv \\left\\{x:f_j(x) = 0\\right\\}\nS_1 \\equiv \\left\\{x:f_j(x) = 1\\right\\}\nSuppose that \\{x_1,...,x_d\\} = S_1, then we can write f_j as a composition of projectors onto the elements of the support, combined with OR operations:\n\nf_j (x)= \\Pi _{x_1} (x)\\lor\\Pi _{x_2} (x)\\lor...\\lor\\Pi _{x_d} (x)\n\\Pi _{z} (x)\\equiv \\left\\{\\begin{array}{l}1 \\quad \\textrm{if }x=z\\\\0 \\quad \\textrm{if }x\\neq z\\end{array}\\right.\nCan the projectors be represented via the universal set defined above?\nYes: they are a composition of AND gates, where the inputs are the elements of x which can be modified by a NOT gate for each position where the reference vector has a 0, e.g.:\n\nThe output is 1 if the input is the same as the reference vector\nMinimal universal gate set\n\nOR gate can be replaced by AND and NOT \nAND and NOT gates can be replaced by NAND  \nNAND and copy can be replaced by: Taking y=1, both the outputs are \\bar{x}.\n"},"Quantum-Information/Quantum-Computation/Classical-Computation/Universal-Turing-Machine-(UTM)":{"slug":"Quantum-Information/Quantum-Computation/Classical-Computation/Universal-Turing-Machine-(UTM)","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Classical Computation/Universal Turing Machine (UTM).md","title":"Universal Turing Machine (UTM)","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Turing-machine"],"tags":[],"content":"\nSince every element for a fixed Turing machine is finite, we can associate said Turing machine to a specific natural number through a bijective function. This numbers are called Turing numbers T_M. Then, we can build a Universal Turing machine which can compute any kind of computable function f by feeding it the Turing number T_M of the machine M capable of computing f, which identifies a specific set of program lines in the program (i.e. those associated with M) and a generic input \\vec{x} separated from T_M by a NULL entry\nUTM(T_M,\\vec{x}) = M(\\vec{x})\nAn UTM can be built out of an alphabet composed of 8 symbols and an finite state control composed of 23 states."},"Quantum-Information/Quantum-Computation/Clifford-operations":{"slug":"Quantum-Information/Quantum-Computation/Clifford-operations","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Clifford operations.md","title":"Clifford operations","links":["Quantum-Information/Quantum-Computation/Quantum-computation","Quantum-Information/Quantum-Computation/Universal-Quantum-Gate-set","Quantum-Information/Quantum-Computation/Hadamard-Gate","Quantum-Information/Quantum-Computation/Phase-gate","Quantum-Information/Quantum-Computation/CNOT-gate","Quantum-Information/Quantum-Computation/Quantum-Toffoli-gate","Quantum-Information/Foundations/Pauli-operators","Group-Theory/Normalizer"],"tags":[],"content":"Clifford operations generate a subset of all possible operations in Quantum computation, see Universal Quantum Gate set for more information. They are unitary, act on any number of qubits and are generated by Hadamard gates H, a specific kind of phase gate and CNOT gates:\n\\textrm{Clifford set}=\\left\\{H, P(\\pi/2), CNOT\\right\\}\\equiv \\left\\{H, S, CNOT\\right\\}\nNote that Toffoli gates can’t be generated using these gates, however Pauli gates can be, as seen below\nPauli operations from Clifford\nTrivially:\nS^2 = Z\nAnd:\nHZH = X\nThen combining those we can build the whole Pauli group.\nClifford operations as Pauli normalizers\nClifford operations generate the Normalizer for the n-qubit Pauli group. In fact, given any n-qubit Clifford operation G and two Pauli operations P,Q, we have that:\nGPG ^\\dagger = \\pm Q\nNote that phases other than \\pm 1 can’t be admitted, as both sides are hermitian."},"Quantum-Information/Quantum-Computation/Computational-basis":{"slug":"Quantum-Information/Quantum-Computation/Computational-basis","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Computational basis.md","title":"Computational basis","links":["Quantum-Information/Quantum-Computation/Quantum-computation","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Foundations/Heisenberg-Weyl-operators"],"tags":[],"content":"The computational basis is the conventional basis used in Quantum computation, composed by the eigenvectors of the Pauli operator Z for computation based on qubits. In the qudit case, we take the eigenvectors of the Heisenberg-Weyl operators Z(a).\nVector form\nUsually, the elements of the basis are denoted by\n\\ket{x}\nWe can apply multiplication and addition on the object x in the form of the logical operations AND and XOR:\nx_1x_2 \\equiv AND(x_1,x_2)\nx_1 + x_2 \\equiv XOR(x_1,x_2)\nWhen we are considering registers of more than one qubit, we denote the computational basis in the compact form\n\\ket{\\vec{x}}\nwhere each component of \\vec{x} represents the state of a single qubit.\nThe AND operation translates to a scalar product where the sum is performed modulus 2. The XOR is taken element-wise."},"Quantum-Information/Quantum-Computation/Controlled-gates":{"slug":"Quantum-Information/Quantum-Computation/Controlled-gates","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Controlled gates.md","title":"Controlled gates","links":["Quantum-Information/Quantum-Computation/Two-qubit-gates"],"tags":[],"content":"\nControlled gates are a class of Two qubit gates which act on one of the qubits as a unitary only when the other qubit is in a specific state, conventionally \\ket{1}, however this can be changed by one qubit gates."},"Quantum-Information/Quantum-Computation/Controlled-unitaries":{"slug":"Quantum-Information/Quantum-Computation/Controlled-unitaries","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Controlled unitaries.md","title":"Controlled unitaries","links":["Quantum-Information/Quantum-Computation/Controlled-gates","Quantum-Information/Foundations/Euler-rotations","Quantum-Information/Quantum-Computation/CNOT-gate","Quantum-Information/Quantum-Computation/One-qubit-gates","Quantum-Information/Quantum-Computation/Computational-basis","Quantum-Information/Quantum-Computation/Classical-Computation/Hamming-Distance","Quantum-Information/Foundations/Qubits"],"tags":[],"content":"Controlled unitaries are Controlled gates that induce a unitary transformation on one qubit when the other is in a specific state.\nUsing a lemma of Euler rotations, which states that any unitary acting on qubits can be written as:\nU = (\\textrm{global phase}) AXBXC\nwhere A,B,C are unitaries such that ABC=\\mathrm{Id}, we can build any controlled unitary using CNOT gates and One qubit gates:\n\nnC-U generalization\nIs it possible to build a unitary transformation, controlled by n qubits, acting on another qubit using only 2 qubit gates? We need auxiliary qubits but it is possible:\n\nArbitrary coupling\nIn the Computational basis, using nC-U operations, we are able to couple (i.e. the initial state and the final state are coupled through a unitary operation) two states which have Hamming Distance of at most 1 between themselves:\n\\ket{y}_A\\ket{\\psi}_B\\mapsto\\left\\{\\begin{array}{l}\\ket{y}_A\\ket{\\psi}_B\\quad\\quad\\forall y\\neq x \\\\ \\ket{x}_AU\\ket{\\psi}_B \\quad\\textrm{ if }y=x\\end{array}\\right.\nHowever, we are still not able to couple two states with arbitrary Hamming distance.\nWe try to build a protocol capable of doing that; we are trying to couple the initial bit string x_1 with the bit string x_2, with x_2 being a target bit string, by sending the qubits in the A register of x_1 to the same state as those of x_2 so that we are in the same situation above; however, we need to be careful to build a circuit that only does this for x_1 (basically, we want to prepare the A register so that its qubits are the same as those in x_2 and then apply the controlled unitary, so that the circuit as a whole is a circuit such is a controlled operation that, if the A register is the same as that of x_1, it gets sent to the A register of x_2 plus a unitary on the B register).\n\nIf two bit strings differ in at least two positions, we can apply a CCNOT operation that only activates for one of the two strings\nWe build a sequence of CCNOT gates that send x_1 to x&#039;_1, which shares the bits in the A registry with x_2\nNow we apply the nC-unitary\nFinally, we apply the preparation protocol in reverse\nUsing an appropriate sequence of CC-NOT operations we can selectively allow for the coupling of any 2 elements of the computational basis through a nC-U operation. Effectively, the unitary acts non trivially only on 2 elements of the computational basis\n\nGeneric unitary\nWe can use the previous result to build generic unitaries acting on n Qubits.\nTheorem\nLet \\mathcal{U} be a generic unitary operation acting on n qubits, so that \\mathcal{U} is a 2^n\\times 2^n matrix. Then, \\exists \\{W_j\\} sequence of gates coupling only 2 strings in the computational basis such that\n\\mathcal{U} = W _t ... W_1\nwhere t is generally a big number t\\sim (2^n)^2.\nProof\nWe start by building the inverse of the last gate, W_t^\\dagger, which is the identity everywhere aside from the first 2 elements of the computational basis\n\\begin{pmatrix} \\frac{\\mathcal{U} ^\\dagger_{11}}{\\gamma} &amp; \\frac{\\mathcal{U} ^\\dagger_{21}}{\\gamma}\\\\ \\frac{\\mathcal{U}_{21}}{\\gamma} &amp; \\frac{\\mathcal{U}_{22}}{\\gamma} \\end{pmatrix}\nBy choosing\n\\gamma \\equiv \\sqrt{\\abs{\\mathcal{U}_{11}}^2+\\abs{\\mathcal{U}_{21}}^2}\nwe can verify that this matrix is unitary\nBy carrying out the matrix multiplication W_t ^\\dagger \\mathcal{U}, it turns out that the matrix in the 21 position is 0. The other elements are non trivial. Let us call the new elements in the positions 11,31,13,33 as \\mathcal{U}_{ij} ^\\prime; then, we can do the same thing with this element, obtaining that the 31 element of W_{t-1}W_t \\mathcal{U} is 0. And so on and so on."},"Quantum-Information/Quantum-Computation/Function-Gate":{"slug":"Quantum-Information/Quantum-Computation/Function-Gate","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Function Gate.md","title":"Function Gate","links":["Quantum-Information/Quantum-Computation/Computational-basis","Quantum-Information/Foundations/Qubits","Quantum-Information/Quantum-Computation/Algorithms/Quantum-algorithms"],"tags":[],"content":"The U_f gate allows for the computation of binary functions on the Computational basis.\n\nThe target functions take on the form:\nf:\\{0,1\\}^{n}\\mapsto \\{0,1\\}^{m}\nConsider two registries of Qubits, A and B. The qubits in A will take on the role of inputs, while the output will be stored in B after the gate. We want to build a unitary gate such that:\nU_f\\left(\\ket{x}_A\\ket{0}_B\\right) = \\ket{x}_A\\ket{f(x)}_B\nFocus on the particular case of m=1\nf:\\{0,1\\}^{n}\\mapsto \\{0,1\\}\nIf input on B register is \\ket{1}, the output needs to be orthogonal to the one above\nU_f\\left(\\ket{x}_A\\ket{1}_B\\right) = \\ket{x}_A\\ket{f(x)\\oplus 1}_B\nConsider a linear combination of elements of the computational basis in B:\n\\frac{\\ket{0}_B-\\ket{1}_B}{\\sqrt{2}}=\\ket{\\psi _-}_B\nUsing linearity, this state is mapped into:\n\\ket{x}_A \\ket{\\psi _-}_B\\overset{U_f}{\\mapsto} \\frac{1}{\\sqrt{2}}\\ket{x}_A\\left(\\ket{f(x)}_B-\\ket{f(x)\\oplus1}\\right)=\\left\\{\\begin{array}{l}\\ket{x}_A\\ket{\\psi _-}_B\\quad \\textrm{if }f(x)=0\\\\\n-\\ket{x}_A\\ket{\\psi _-}_B\\quad \\textrm{if }f(x)=1\\end{array}\\right.\nOr, in a more compact form\n\nWe started from a definition where, apparently, the A register controls the B register. However, selecting a specific input for B, we wind up in a situation where the A register is controlled by B.\n\\left(\\sum_x \\alpha _x \\ket{x}_A\\right)\\ket{\\psi_-}_B\\mapsto\\left(\\sum_x (-1)^{f(x)} \\alpha _x \\ket{x}_A\\right)\\ket{\\psi_-}_B\nThis is important as this means that we are able to encode f(x) into the relative phases of the A register. See Quantum algorithms."},"Quantum-Information/Quantum-Computation/Gottesman-Knill-theorem":{"slug":"Quantum-Information/Quantum-Computation/Gottesman-Knill-theorem","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Gottesman-Knill theorem.md","title":"Gottesman-Knill theorem","links":["Quantum-Information/Quantum-Computation/One-qubit-gates","Quantum-Information/Quantum-Computation/Two-qubit-gates","Quantum-Information/Quantum-Computation/Classical-Computation/Classical-computation","Quantum-Information/Entanglement/Entangled-states","Quantum-Information/Entanglement/Bell-states"],"tags":[],"content":"Any quantum computer containing only the gates (see One qubit gates, Two qubit gates) \\{H,P(\\pi/2),CNOT\\} can be efficiently classically simulated.\nIn this context, the difference between quantum and Classical computation is just one gate:\nP(\\pi/2) \\leftrightarrow P(\\pi/4)\nNotice that these simulable machines can still generate Entangled states (see Bell states)"},"Quantum-Information/Quantum-Computation/Hadamard-Gate":{"slug":"Quantum-Information/Quantum-Computation/Hadamard-Gate","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Hadamard Gate.md","title":"Hadamard Gate","links":["Quantum-Information/Foundations/Qubits","Quantum-Information/Quantum-Computation/One-qubit-gates","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Quantum-Computation/Computational-basis"],"tags":[],"content":"\nThe Hadamard gate is a transformation induced on Qubits carried out by the operator:\nH \\equiv \\frac{1}{\\sqrt{2}} \\begin{pmatrix}1 &amp;1 \\\\ 1 &amp; -1\\end{pmatrix}\nIn terms of one qubit unitaries:\nH=\\frac{1}{\\sqrt{2}}\\left(\\begin{array}{cc}1 &amp; 1\\\\\n1 &amp; -1\\end{array}\\right) = e^{i\\pi}U_{\\hat{m}}(\\pi)\n\\hat{m} = \\frac{1}{\\sqrt{2}}(1,0,1)\nThe corresponding angle is depicted in the figure above.\nPractically, this transformation sends eigenvectors of the Z operator into eigenvectors of the X operator and viceversa (see Pauli operators):\n\nH\\ket{0} =\\ket{+}\nH\\ket{1} =\\ket{-}\nH^2 = \\id_2\nIn terms of Computational basis:\n\\ket{x}\\overset{H}{\\mapsto}\\frac{1}{\\sqrt{2}}\\left(\\ket{0} + (-1)^{x}\\ket{1}\\right)\nGlobal Hadamard gate\n\nWe are working in the Computational basis\nIt produces superpositions of all elements of the computational basis, whatever the inputs, given N\\equiv 2^n\n\\ket{x}\\mapsto\\frac{1}{\\sqrt{N}}\\sum_y(-1)^{x\\cdot y}\\ket{y}\n\\ket{0}^{\\otimes n} \\mapsto \\sum_y\\frac{\\ket{y}}{\\sqrt{N}}\nQudit Hadamard\n\\begin{gathered}\nH_d|j\\rangle=\\frac{1}{\\sqrt{d}} \\sum_{i=0}^{d-1} \\omega^{i j}|i\\rangle, j \\in\\{0,1,2, \\ldots, d-1\\}, \\\\\n\\omega:=\\mathrm{e}^{2 \\pi \\mathrm{i} / d} .\n\\end{gathered}\nTransformation acting on two memory registers"},"Quantum-Information/Quantum-Computation/One-qubit-gates":{"slug":"Quantum-Information/Quantum-Computation/One-qubit-gates","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/One qubit gates.md","title":"One qubit gates","links":["Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Quantum-Computation/Quantum-computation","Quantum-Information/Quantum-Computation/Phase-gate","Quantum-Information/Quantum-Computation/Hadamard-Gate","Quantum-Information/Quantum-Computation/One-qubit-minimal-gate-set"],"tags":[],"content":"Given the Pauli operators \\sigma = \\{\\sigma_x ,\\sigma_y,\\sigma_z\\}, a generic qubit unitary U can be written as\nU = e ^{i\\phi} U_{\\hat{n}}(\\theta)\nwhere U_{\\hat{n}}(\\theta) is a rotation of angle \\theta around the unit vector \\hat{n}:\nU_{\\hat{n}}(\\theta) = e^{-i\\frac{\\theta}{2} \\hat{n}\\sigma}\nU^\\dagger_{\\hat{n}}(\\theta)\\sigma U_{\\hat{n}}(\\theta)= R(\\theta)_{\\hat{n}}\\sigma\nU^\\dagger_{\\hat{n}}(\\theta)\\sigma _i U_{\\hat{n}}(\\theta)= \\sum_j\\left(R(\\theta)_{\\hat{n}}\\right)_{ij}\\sigma_j\nU_{\\hat{n}}(\\theta) = \\cos \\frac{\\theta}{2}\\mathrm{Id}-i\\sin\\frac{\\theta}{2}n_i\\sigma_i\nUsing these unitaries, all 1 qubit gates for Quantum computation are built:\n\nPhase gate\nHadamard Gate\nSee One qubit minimal gate set\n"},"Quantum-Information/Quantum-Computation/One-qubit-minimal-gate-set":{"slug":"Quantum-Information/Quantum-Computation/One-qubit-minimal-gate-set","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/One qubit minimal gate set.md","title":"One qubit minimal gate set","links":["Quantum-Information/Quantum-Computation/Phase-gate","Quantum-Information/Quantum-Computation/Hadamard-Gate","Quantum-Information/Quantum-Computation/One-qubit-gates","Quantum-Information/Foundations/Euler-rotations"],"tags":[],"content":"We want to prove that the set:\n\\left\\{\\{P(\\phi)\\}_\\phi,H \\right\\}\nwhere P(\\phi) is a Phase gate and H is a Hadamard Gate, can reproduce all One qubit gates.\nSome useful identities:\nHZH = X\nHP(\\phi)H = ...= e^{i\\phi/2}U_{\\hat{x}}(\\phi)\nSo that we can substitute Hadamard gates and phase gates into the Euler rotations:\nU_{\\hat{n}} (\\theta) = P(\\alpha _1)HP(\\alpha _2)HP(\\alpha _3)\nSo that any unitary on single qubits is built from these two gates\nMore practical set\nAnother more practical, yet approximate, universal set is:\n\\{P(\\pi/4),H\\}\nwe must set a target for accuracy:\nU_{\\hat{n}}(\\theta)\\mapsto U^\\prime:\\norm{U^\\prime - U_{\\hat{n}}(\\theta)}&lt;\\epsilon\nThis can be done through the generalized Euler theorem. In order to do so, we need to generate generic rotations around two different axes using the two gates above.\nWe define the first rotation:\nP(\\pi/4)HP(\\pi/4)H = e^{i\\pi/4}U_{\\hat{n}}(\\theta)\nwhere:\nn\\propto\\left(\\cos\\frac{\\pi}{8},\\sin\\frac{\\pi}{8},\\cos\\frac{\\pi}{8}\\right)\n\\theta:\\cos\\frac{\\theta}{2} = \\cos^2\\frac{\\pi}{8}\nIt turns out that \\theta/\\pi is irrational, so it generates aperiodic rotations if applied multiple times\n\\left(P(\\pi/4)HP(\\pi/4)H\\right)^N = e^{i\\pi/4}U_{\\hat{n}}(\\tilde{\\theta})\nThe other rotations are found through:\nHP(\\pi/4)HP(\\pi/4) = e^{i\\pi/4}U_{\\hat{m}}(\\theta)\nwhere:\nm\\propto\\left(\\cos\\frac{\\pi}{8},-\\sin\\frac{\\pi}{8},\\cos\\frac{\\pi}{8}\\right)"},"Quantum-Information/Quantum-Computation/Phase-gate":{"slug":"Quantum-Information/Quantum-Computation/Phase-gate","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Phase gate.md","title":"Phase gate","links":["Quantum-Information/Quantum-Computation/Computational-basis","Quantum-Information/Quantum-Computation/Controlled-gates","Quantum-Information/Quantum-Computation/Quantum-computation","Quantum-Information/Quantum-Computation/One-qubit-minimal-gate-set"],"tags":[],"content":"The phase gate is identified by the unitary:\nP(\\phi) =\\left(\n\\begin{array}{cc}1 &amp; 0\\\\\n0 &amp; e^{i\\phi}\n\\end{array}\n\\right) = e ^{i\\phi/2}U_{\\hat{z}}(\\phi)\nIt acts on the Computational basis as:\n\\ket{0}\\mapsto \\ket{0}\n\\ket{1}\\mapsto e^{i\\phi}\\ket{1}\nSo, it induces a relative phase between elements of the basis\n\\ket{x}\\overset{P(\\phi)}{\\mapsto}e^{i\\phi x}\\ket{x}\nControlled version\nThe controlled version of the phase gate induces the following transformation\n\\ket{x_0}_A\\ket{x_1}_B\\overset{CP(\\phi)}{\\mapsto}\\ket{x_0}_Ae^{i\\phi x_0x_1}\\ket{x_1}_B\nImportant phase gates\nAn important role in Quantum computation is played by the gate P(\\pi/4), also called T gate, see One qubit minimal gate set.\nT gates\nWe define the T gates with:\nT\\equiv P(\\pi/4) =\\left(\n\\begin{array}{cc}1 &amp; 0\\\\\n0 &amp; e^{i\\pi/4}\n\\end{array}\n\\right)\nS gates\nWe define the S gates with:\nS\\equiv P(\\pi/2) = T^2 =\\left(\n\\begin{array}{cc}1 &amp; 0\\\\\n0 &amp; i\n\\end{array}\n\\right)"},"Quantum-Information/Quantum-Computation/Quantum-Toffoli-gate":{"slug":"Quantum-Information/Quantum-Computation/Quantum-Toffoli-gate","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Quantum Toffoli gate.md","title":"Quantum Toffoli gate","links":["Quantum-Information/Quantum-Computation/CNOT-gate","Quantum-Information/Quantum-Computation/Classical-Computation/Toffoli-gate","Quantum-Information/Quantum-Computation/Controlled-unitaries","Quantum-Information/Foundations/Pauli-operators"],"tags":[],"content":"The quantum Toffoli gate is a CCNOT (see CNOT gate, Toffoli gate)\nConsider a CC-unitary:\nThis transformation can be realized by two qubit gates.\nTake the square root of U, which is still a unitary:\nV: V=\\sqrt{U}\nThen:\n\nUsing this protocol, quantum Toffoli gates can be built using 2-body invertible interactions, which is not possible classically (3-body interactions are required)\nThe square root of the X (NOT) operator is:\n\\sqrt{X} = \\frac{1}{2}\\begin{pmatrix}1+i &amp;1-i\\\\1-i &amp; 1+i\\end{pmatrix} = \\frac{1}{2}\\left((1+i)\\id + (1-i) X\\right)"},"Quantum-Information/Quantum-Computation/Quantum-computation":{"slug":"Quantum-Information/Quantum-Computation/Quantum-computation","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Quantum computation.md","title":"Quantum computation","links":["Quantum-Information/Quantum-Computation/Classical-Computation/Gate-array-model-(classical)","Quantum-Information/Quantum-Computation/One-qubit-gates","Quantum-Information/Quantum-Computation/Two-qubit-gates"],"tags":[],"content":"A quantum computation model is built using a gate array model (compare to Gate array model (classical)). We either have:\n\nOne qubit gates\nTwo qubit gates\n"},"Quantum-Information/Quantum-Computation/Swap-gates":{"slug":"Quantum-Information/Quantum-Computation/Swap-gates","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Swap gates.md","title":"Swap gates","links":[],"tags":[],"content":"\nUseful because quantum computers are many body systems that are governed by a give hamiltonian. Typically, the interactions involved in the hamiltonian are first neighbor interactions."},"Quantum-Information/Quantum-Computation/Two-qubit-gates":{"slug":"Quantum-Information/Quantum-Computation/Two-qubit-gates","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Two qubit gates.md","title":"Two qubit gates","links":["Quantum-Information/Quantum-Computation/Universal-Quantum-Gate-set","Quantum-Information/Quantum-Computation/CNOT-gate"],"tags":[],"content":"Two qubit gates act non trivially on the values of two qubits. They could be represented by a global unitary on the Hilbert spaces of these qubits. However, it turns out that in order to achieve a Universal Quantum Gate set, we only need one type of two qubit gate ⇒ CNOT gate"},"Quantum-Information/Quantum-Computation/Universal-Quantum-Gate-set":{"slug":"Quantum-Information/Quantum-Computation/Universal-Quantum-Gate-set","filePath":"../PhysicsVault/Quantum Information/Quantum Computation/Universal Quantum Gate set.md","title":"Universal Quantum Gate set","links":["Quantum-Information/Quantum-Computation/One-qubit-minimal-gate-set","Quantum-Information/Quantum-Computation/CNOT-gate","Quantum-Information/Quantum-Computation/Controlled-unitaries","Quantum-Information/Quantum-Computation/Quantum-Toffoli-gate"],"tags":[],"content":"The universal set for quantum computations is given by the One qubit minimal gate set coupled with the CNOT gate\n\\{\\textrm{One qubit gates},\\mathrm{CNOT}\\}\nUsing Controlled unitaries, any kind of global unitary acting on two qubits can be constructed.\nAnother universal set is given by:\n\\{H,P(\\pi/2),\\mathrm{QTOFFOLI}\\}\nsee Quantum Toffoli gate."},"Quantum-Information/Quantum-Cryptography/Classical-Cryptography/Classical-Cryptography":{"slug":"Quantum-Information/Quantum-Cryptography/Classical-Cryptography/Classical-Cryptography","filePath":"../PhysicsVault/Quantum Information/Quantum Cryptography/Classical Cryptography/Classical Cryptography.md","title":"Classical Cryptography","links":["Quantum-Information/Quantum-Cryptography/Classical-Cryptography/One-time-pad","Quantum-Information/Quantum-Cryptography/Classical-Cryptography/Public-key-cryptographic-schemes"],"tags":[],"content":"\nThe ideal setting of classical cryptography is the following: Alice wants to send a classical message, i.e. a message that can be encoded in a string of bits, to Bob using a classical communication line (e.g. telephone, pigeon…). The classical communication line can be accessed by an external, possibly malicious party, called Eve, who tries to intercept the message Alice wants to send.\nIn order for Alice and Bob to communicate without having Eve read the messages, they need to agree on a protocol that would render the messages readable only for them, i.e. they need to devise an effective encoding and decoding process.\nA very simple classical cryptographic protocol is the One-time pad, which is however problematic when we want to perform the communication over multiple uses of the channel. To solve this problem, Public-key cryptographic schemes were devised.\nIn general, cryptographic schemes rely on the existence of functions such that:\nf(\\vec{M},key) = \\vec{m}\nwhere \\vec{m} is the message and \\vec{M} is the encrypted message, which are easy to compute, while functions of the type:\ng(\\vec{M}) = \\vec{m}\nare very hard to compute."},"Quantum-Information/Quantum-Cryptography/Classical-Cryptography/One-time-pad":{"slug":"Quantum-Information/Quantum-Cryptography/Classical-Cryptography/One-time-pad","filePath":"../PhysicsVault/Quantum Information/Quantum Cryptography/Classical Cryptography/One-time pad.md","title":"One-time pad","links":["Quantum-Information/Quantum-Cryptography/Classical-Cryptography/Classical-Cryptography"],"tags":[],"content":"In the setting described in Classical Cryptography, Alice and Bob share a string of n random bits, which they previously prepared:\n\\vec{x} = (x_0,...,x_{n-1})\nEve does not have access to \\vec{x} (secret).\nLet us call \\vec{m} the message Alice wants to send to Bob, which is a sequence of bits. Then we define the encoded message:\n\\vec{M}\\equiv\\vec{m}\\oplus\\vec{x}\nThe one-time pad protocol works as follows:\n\nAlice encodes the message \\vec{m} in \\vec{M}\nBob can then decode the message by performing \\vec{M}\\oplus\\vec{x} = \\vec{m}. It can be shown that the mutual info I(M,m) = 0.\nThis protocol is usually referred to as unconditionally secure (secure regardless of Eve’s decoding ability).\nThe problem with one-time pad is repeatability: if the protocol is repeated without changing \\vec{x}, Eve can recover some information on \\vec{x} and therefore on the messages:\n\nM\\oplus M&#039; = m\\oplus m&#039;"},"Quantum-Information/Quantum-Cryptography/Classical-Cryptography/Public-key-cryptographic-schemes":{"slug":"Quantum-Information/Quantum-Cryptography/Classical-Cryptography/Public-key-cryptographic-schemes","filePath":"../PhysicsVault/Quantum Information/Quantum Cryptography/Classical Cryptography/Public-key cryptographic schemes.md","title":"Public-key cryptographic schemes","links":["Quantum-Information/Quantum-Cryptography/Classical-Cryptography/Classical-Cryptography"],"tags":[],"content":"In the setting described in Classical Cryptography, Alice and Bob agree on the following protocol:\n\nBob produces a couple of strings: a public one x_{pub} and a private one (only known by him) x_{pr}.\nThe effectiveness of public-key schemes relies on the existence of an encoding such that, for a message \\vec{m}:\nE(\\vec{m},\\vec{x_{pub}}) = \\vec{M}\nso that the map M\\mapsto m is a hard problem if only x_{pub} is known, and a decoding function such that:\nD(\\vec{M},\\vec{x_{pr}}) = \\vec{m}\n\nAlice sends \\vec{M} = E(\\vec{m},\\vec{x_{pub}}) to Bob\nEve cannot decrypt \\vec{M}\nBob receives \\vec{m} = D(\\vec{M},\\vec{x_{pr}})\nThis protocol is not unconditionally secure. RSA is an example of public-key cryptographic schemes.\n"},"Quantum-Information/Quantum-Cryptography/Protocols/B92":{"slug":"Quantum-Information/Quantum-Cryptography/Protocols/B92","filePath":"../PhysicsVault/Quantum Information/Quantum Cryptography/Protocols/B92.md","title":"B92","links":["Quantum-Information/Quantum-Cryptography/Quantum-Cryptography","Quantum-Information/Quantum-Cryptography/Protocols/BB84"],"tags":[],"content":"The functioning of this quantum key distribution protocol is similar to the one of BB84, but it employs fewer resources:\n\nAlice only generates a, so that if a_j =0, \\ket{\\psi }_j = \\ket{0} and if a_j = 1, \\ket{\\psi}_j = \\ket{+}.\nBob does the same as in the BB84\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\na_jc_jm_j00perf corr10random01random11perf corr\n\nWe work under the rule that when perfect correlation happens, m_j =0. If Bob measures 0, he can’t know whether the input state was a 0 or a +, but if he measures a 1, he knows for sure that a_j \\neq c_j. This happens 25% of the times.\nBob reveals the outcome of the measurements. He and Alice only keep the outcomes corresponding to m_j= 1.\nDetecting the presence of Eve is the same as in BB84.\n"},"Quantum-Information/Quantum-Cryptography/Protocols/BB84":{"slug":"Quantum-Information/Quantum-Cryptography/Protocols/BB84","filePath":"../PhysicsVault/Quantum Information/Quantum Cryptography/Protocols/BB84.md","title":"BB84","links":["Quantum-Information/Quantum-Cryptography/Quantum-Cryptography","Quantum-Information/Foundations/Pauli-operators"],"tags":[],"content":"This quantum key distribution protocol works as follows:\n\nAlice selects two random strings of n bits a,b, needed to decide what types of states to send through the communication line. a will contain the private key.\na,b are used to create a sequence of n qubits so that the state of the j-th qubit is\n\\ket{\\psi}_j = \\ket{\\psi (a_j,b_j)}_j\nThe table of truth for the encoding is:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\na_jb_j\\ket{\\psi}_j00\\ket{0}10\\ket{1}01\\ket{+}11\\ket{-}\n\nThe qubits travel through the communication line independently\nBob has created a random sequence of n bits c.\nWhen the j-th qubit arrives, if c_j = 0 Bob performs a Z measurement on the qubit, otherwise he performs an X measurement (see Pauli operators). Call m_j the outcome of the measurement, we have the following table of truth\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nb_jc_jm_j00perf corr10random01random11perf corr\n\nWhen b_j = c_j, perfect match m_j = a_j, otherwise there is no correlation. Perfect correlation happens with a rate of 50%.\nAfter the measurements, Bob broadcasts c on the public classical channel.\nAlice broadcasts when b_j = c_j, so that the random cases are discarded. Now both Alice and Bob share the remaining bits of a.\nIf Eve tries to intercept the message, the measurement Bob performs in the cases of perfect correlation will have a certain probability that a_j \\neq m_j\nEve interference can be detected by selecting a batch of length k from the n/2 remaining bits and checking for discrepancies.\n"},"Quantum-Information/Quantum-Cryptography/Protocols/Ekert-protocol-(E91)":{"slug":"Quantum-Information/Quantum-Cryptography/Protocols/Ekert-protocol-(E91)","filePath":"../PhysicsVault/Quantum Information/Quantum Cryptography/Protocols/Ekert protocol (E91).md","title":"Ekert protocol (E91)","links":["Quantum-Information/Entanglement/Entangled-states","Quantum-Information/Quantum-Cryptography/Quantum-Cryptography","Quantum-Information/Entanglement/Bell-states"],"tags":[],"content":"The Ekert protocol, or protocol, has no real practical use but grants insight into entanglement. Its outline is as follows (we are always working in the ideal setting described in Quantum Cryptography):\n\nAlice creates n Bell states, one qubit is sent to Bob so that the two of them share n couples of maximally entangled states\nBy performing local measurements, they can transform the bell states into shared randomness.\nIf Eve interferes, the couples may no longer be maximally entangled\nA and B perform a Bell test on a batch of K couples to detect Eve\n"},"Quantum-Information/Quantum-Cryptography/Quantum-Cryptography":{"slug":"Quantum-Information/Quantum-Cryptography/Quantum-Cryptography","filePath":"../PhysicsVault/Quantum Information/Quantum Cryptography/Quantum Cryptography.md","title":"Quantum Cryptography","links":["Quantum-Information/Quantum-Cryptography/Classical-Cryptography/Classical-Cryptography","Quantum-Information/Quantum-Cryptography/Classical-Cryptography/One-time-pad","Quantum-Information/Entanglement/Impossible-machines/Quantum-cloner","Quantum-Information/Open-system-dynamics/Quantum-channel-representations","Quantum-Information/Quantum-Cryptography/Protocols/BB84","Quantum-Information/Quantum-Cryptography/Protocols/B92","Quantum-Information/Quantum-Cryptography/Protocols/Ekert-protocol-(E91)"],"tags":[],"content":"The ideal setting is the same as the one described in Classical Cryptography\n\nthe difference being that the communication line is a quantum communication line (i.e. flying qubits, fiber optic cable…). The message to be transmitted is still classical.\nQuantum key distribution\nQuantum cryptography allows Alice and Bob to share a random string of bits on the public channel in a secure manner, so that e.g. One-time pad is feasible multiple times.\nThe scheme goes roughly as follows: A sends a quantum message to B. B performs a measurement on the message which reveals two things:\n\nWhether E read the message (information disturbance trade-off)\nThe key to be distributed\nInformation disturbance trade-off is basically a by-product of the no cloning theorem (see Quantum cloner). In fact, if classical information could be recovered from a quantum state without altering it (i.e. E reading the message without anyone noticing), the procedure could be used many times to construct a quantum cloner. In the Stinespring representation, this would mean:\n\nU\\ket{\\psi}_S\\ket{0}_E = \\ket{\\psi}_S\\ket{f(\\psi)}_E\nU\\ket{\\phi}_S\\ket{0}_E = \\ket{\\phi}_S\\ket{f(\\phi)}_E\nThen take the scalar product, considering that f has no dependence on its input state.\nMost famous quantum key distribution protocols:\n\nBB84\nB92\nEkert protocol (E91)\n"},"Quantum-Information/Quantum-Error-Correction/3-qubits-code":{"slug":"Quantum-Information/Quantum-Error-Correction/3-qubits-code","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/3 qubits code.md","title":"3 qubits code","links":["Quantum-Information/Quantum-Error-Correction/Bit-flip-error---3-qubits","Quantum-Information/Quantum-Error-Correction/Phase-flip-error---3-qubits"],"tags":[],"content":"Two types of error are treated:\n\nBit-flip error - 3 qubits\nPhase-flip error - 3 qubits\n"},"Quantum-Information/Quantum-Error-Correction/9-qubits-code-(Shor's-code)":{"slug":"Quantum-Information/Quantum-Error-Correction/9-qubits-code-(Shor's-code)","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/9 qubits code (Shor's code).md","title":"9 qubits code (Shor's code)","links":["Quantum-Information/Foundations/Qubits","Quantum-Information/Quantum-Error-Correction/Quantum-Error-Correction-(QEC)","Quantum-Information/Quantum-Error-Correction/3-qubits-code","Quantum-Information/Quantum-Error-Correction/Logical-qubits","Quantum-Information/Quantum-Computation/Hadamard-Gate","Quantum-Information/Quantum-Computation/CNOT-gate","Quantum-Information/Notable-channels/Bit-flip-channel","Quantum-Information/Quantum-Error-Correction/Bit-flip-error---3-qubits","Quantum-Information/Notable-channels/Dephasing-channel","Quantum-Information/Open-system-dynamics/Stinespring-dilation","Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Notable-channels/Pauli-channels","Quantum-Information/Foundations/Pure-states","Quantum-Information/Quantum-Error-Correction/Generic-Error-Correction-module","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Minimal-1-qubit-error-code"],"tags":[],"content":"Using encoding on 9 Qubits, it is possible to correct any kind of noise induced on a single qubit.\nThe 9 qubits code encompasses both the 3 qubits code and incidentally this leads to general error correction on a single qubit.\nThe qubit we want to encode is:\n\\ket{\\psi} = \\alpha \\ket{0} +\\beta \\ket{1}\nLabel the 9 physical qubits as 0,1,…,8. The basis for the logical qubit is:\n\\ket{0}_L \\equiv\\left(\\frac{\\ket{000}+\\ket{111}}{\\sqrt{2}}\\right)^{\\otimes 3}\n\\ket{1}_L \\equiv\\left(\\frac{\\ket{000}-\\ket{111}}{\\sqrt{2}}\\right)^{\\otimes 3}\n\\ket{\\psi }_L = \\alpha \\ket{0}_L + \\beta \\ket{1}_L\nEncoding\n\nWe use a sequence of Hadamard Gates and CNOT gates. Basically, the first step is the encoding as seen in the phase-flip error correction on 3 qubits, while the second step is the encoding as seen in the bit-flip for each of these 3 qubits (so 9 qubits total).\nThe logical qubit is:\n\\ket{\\psi}_L = \\alpha\\left(\\frac{\\ket{000}+\\ket{111}}{\\sqrt{2}}\\right)^{\\otimes 3}+\\beta\\left(\\frac{\\ket{000}-\\ket{111}}{\\sqrt{2}}\\right)^{\\otimes 3}\nError syndrome measurement\nThe measurements we need to perform are:\n\nSequence of Z measurements:\n\nZ_0\\otimes Z_1\nZ_1\\otimes Z_2\nZ_3\\otimes Z_4\nZ_4\\otimes Z_5\nZ_6\\otimes Z_7\nZ_7\\otimes Z_8\n\n\nSequence of X measurements:\n\n\\Omega _0 \\equiv X_0X_1X_2X_3X_4X_5\n\\Omega _1 \\equiv X_3X_4X_5X_6X_7X_8\nThe error correction protocol is the following:\n\n\nThe Z measurements commute and are used to detect bit-flip errors for each triplet (see Bit-flip error - 3 qubits)\nCorrect bit-flips if found\nThe \\Omega _i commute. These two measurements provide two bits of information: whether a single phase-flip occurred and in which triplet (we don’t need more bits of info as phase flip e.g. in 0,1,2 are mutually indistinguishable in our code)\nCorrect phase-flip if found\n\nNoise at Stinespring dilation level\nAt the Stinespring dilation level, any qubit channel is almost a Pauli channel\n\\mathcal{N} (\\rho) = \\tr _E \\left(U_{SE}(\\rho _S \\ket{0}_E\\bra{0})U_{SE} ^\\dagger\\right)\nBefore tracing out the environment, for Pure states we have\n\\ket{\\psi}_S \\mapsto U_{SE} \\ket{\\psi}_S\\ket{0}_E\n\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1}\nWe define the (not normalized) vectors:\n\\ket{g _{ij}}_E \\equiv {}_S\\bra{i}U_{SE}\\ket{j}_S\\ket{0}_E\nso that:\n\\ket{\\psi } _S \\mapsto \\alpha\\ket{0}_S\\ket{g_{00}}_E+\\alpha\\ket{1}_S\\ket{g_{10}}_E+\\beta\\ket{0}_S\\ket{g_{01}}_E+\\beta\\ket{1}_S\\ket{g_{11}}_E\nThis can be rewritten as\nU_{SE} \\ket{\\psi}_S\\ket{0}_E =  \\frac{\\ket{g_{00}}_E+\\ket{g_{11}}_E}{2}\\ket{\\psi}_S + \\frac{\\ket{g_{00}}_E-\\ket{g_{11}}_E}{2}Z\\ket{\\psi}_S+ \\frac{\\ket{g_{10}}_E+\\ket{g_{01}}_E}{2}X\\ket{\\psi}_S+ \\frac{\\ket{g_{10}}_E-\\ket{g_{11}}_E}{2}iY\\ket{\\psi}_S\nWe can label the vectors of the environment for easier reading:\nU_{SE} \\ket{\\psi}_S\\ket{0}_E =  \\ket{\\mathbb{1}}_E\\otimes\\ket{\\psi}_S + \\ket{Z}_E\\otimes Z\\ket{\\psi}_S+ \\ket{X}_E\\otimes X\\ket{\\psi}_S+ \\ket{Y}_E \\otimes Y\\ket{\\psi}_S\nU_{SE} \\ket{\\psi}_S\\ket{0}_E =  \\ket{\\mathbb{1}}_E\\otimes\\ket{\\psi}_S + \\ket{Z}_E\\otimes Z\\ket{\\psi}_S+ \\ket{X}_E\\otimes X\\ket{\\psi}_S- \\ket{Y}_E \\otimes XZ\\ket{\\psi}_S\nWhen tracing the environment, we only obtain a Pauli channel if the vectors of the environment are orthogonal, otherwise mixed terms are found.\nError correction\nWe use the modified version of the Generic Error Correction module:\n\n\\mathcal{D} \\equiv \\sum _k \\ket{k}_A\\bra{k}\\otimes\\mathcal{D}_k\nRealistically (in the lab), it’s easier to do classical control, quantum control is easier to deal with mathematically. Also, performing a measurement on A after the quantum controlled gate \\mathcal{D} is the same as performing the standard QEC.\nWe now apply this formalism to the 9 qubit code\n\nLet’s see what happens at each stage. Stages 2-3 correct bit flip error and 4-5 correct phase flip error.\n\\ket{\\Psi} _0 = \\ket{\\psi}_L\\ket{0}_{E}\\ket{0}_{A_1}\\ket{0}_{A_2}\n\\ket{\\Psi} _1 = \\left(U_{SE} \\ket{\\psi} _L \\ket{0} _E\\right) \\ket{0}_{A_1}\\ket{0}_{A_2}\nAt stage 2, each time there is a bit flip (X), that information is registered in A_1\n\\begin{split}\n\\ket{\\Psi}_2  \\,=\\quad &amp;\\ket{\\psi}_L\\ket{\\mathbb{1}}_{E}\\ket{0}_{A_1}\\ket{0}_{A_2} + X_S\\ket{\\psi}_L\\ket{X}_{E}\\ket{\\color{violet}X_S}_{A_1}\\ket{0}_{A_2}-\\\\ &amp; X_S Z_S\\ket{\\psi}_L\\ket{Y}_{E}\\ket{\\color{violet}X_S}_{A_1}\\ket{0}_{A_2} + Z_S\\ket{\\psi}_L\\ket{Z}_{E}\\ket{0}_{A_1}\\ket{0}_{A_2}\n\\end{split}\nAt stage 3, if A_1 is in the \\ket{X_S} state, apply X_S (meaning on the right position in the triplet).\n\\begin{split}\n\\ket{\\Psi}_3  \\,=\\quad &amp;\\ket{\\psi}_L\\ket{\\mathbb{1}}_{E}\\ket{0}_{A_1}\\ket{0}_{A_2} + \\ket{\\psi}_L\\ket{X}_{E}\\ket{\\color{violet}X_S}_{A_1}\\ket{0}_{A_2}-\\\\ &amp; Z_S\\ket{\\psi}_L\\ket{Y}_{E}\\ket{\\color{violet}X_S}_{A_1}\\ket{0}_{A_2} + Z_S\\ket{\\psi}_L\\ket{Z}_{E}\\ket{0}_{A_1}\\ket{0}_{A_2}\n\\end{split}\nAt stage 4, each time there is a phase flip (Z), that information is stored in A_2\n\\begin{split}\n\\ket{\\Psi}_4  \\,=\\quad &amp;\\ket{\\psi}_L\\ket{\\mathbb{1}}_{E}\\ket{0}_{A_1}\\ket{0}_{A_2} + \\ket{\\psi}_L\\ket{X}_{E}\\ket{X_S}_{A_1}\\ket{0}_{A_2}-\\\\ &amp; Z_S\\ket{\\psi}_L\\ket{Y}_{E}\\ket{X_S}_{A_1}\\ket{\\color{violet}Z_S}_{A_2} + Z_S\\ket{\\psi}_L\\ket{Z}_{E}\\ket{0}_{A_1}\\ket{\\color{violet}Z_S}_{A_2}\n\\end{split}\nAt stage 5, if A_2 is in the Z_S state, apply Z_S:\n\\begin{split}\n\\ket{\\Psi}_5  \\,=\\quad &amp;\\ket{\\psi}_L\\ket{\\mathbb{1}}_{E}\\ket{0}_{A_1}\\ket{0}_{A_2} + \\ket{\\psi}_L\\ket{X}_{E}\\ket{X_S}_{A_1}\\ket{0}_{A_2}-\\\\ &amp; \\ket{\\psi}_L\\ket{Y}_{E}\\ket{X_S}_{A_1}\\ket{\\color{violet}Z_S}_{A_2} + \\ket{\\psi}_L\\ket{Z}_{E}\\ket{0}_{A_1}\\ket{\\color{violet}Z_S}_{A_2}\n\\end{split}\nThe final state of the system L is \\ket{\\psi}_L.\nLooking at the final state of EA, it is similar to the initial state LE, as if the correlations were transferred (like an entropy pump).\nThe 9 qubit code is not the most efficient, 5 qubits suffice for single qubit errors, see Minimal 1 qubit error code. Indeed, there are other errors aside from single qubit errors that are corrected by this code (e.g. two phase flip in the same triplets, 3 phase flips in the same triplets, 3 bit flip in the 3 different triplets).\nGenerally speaking, if we have n physical qubits, upon which a maximum number e of simultaneous local errors can occur, there is a maximum number of logical qubits k which can be extracted, given by the condition\nn\\geq 4e +k\nThis picture can be reversed: if we need k logical qubits, and in our quantum computer a maximum e of local errors happen at the same time, then the employed physical qubits are lower bounded by the relation above."},"Quantum-Information/Quantum-Error-Correction/Bit-flip-error---3-qubits":{"slug":"Quantum-Information/Quantum-Error-Correction/Bit-flip-error---3-qubits","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Bit-flip error - 3 qubits.md","title":"Bit-flip error - 3 qubits","links":["Quantum-Information/Foundations/Qubits","Quantum-Information/Notable-channels/Bit-flip-channel","Quantum-Information/Quantum-Computation/CNOT-gate","Quantum-Information/Quantum-Error-Correction/Logical-qubits","Quantum-Information/Quantum-Computation/Computational-basis"],"tags":[],"content":"Consider that the source of noise on the Qubits in a machine induces an unwanted bit-flip transformation:\n\\Phi (\\rho ) = (1-p) \\rho + p X\\rho X\nIn the classical case, such an error could be dealt with by encoding the information of the bit into 3 bits, and if the probability of error p is low enough, a majority rule could be implemented with high confidence.\nThis cannot be directly translated to the quantum case.\nEncoding\nWe use a couple of CNOT gates\n\nGiven a state\n\\ket{\\psi} = \\alpha \\ket{0} +\\beta \\ket{1}\nwe need to encode \\alpha,\\beta in 3 qubits. This can be achieved through entanglement:\n\\ket{\\psi}_L = \\alpha\\ket{000} +\\beta\\ket{111} \\equiv\\alpha \\ket{0}_L +\\beta \\ket{1}_L\n\\ket{\\psi}_L is the logical qubit of our encoding, which can be produced through the procedure depicted in the figure above.\n\nThe Hilbert space \\mathcal{H}_2^{\\otimes 3} is split into 4 non intersecting hyperplanes. If at most 1 error occurs, we can identify these hyperplanes with the error itself. This implies that we can recover 2 bits of classical information by projecting onto these hyperplanes, which tell us if and where the error occurred. Once we have that information, we can correct the error. 2 errors or more are very unlikely so we discard the option.\nError syndrome measurement\nThe error correcting procedure works as depicted:\n\nAnd the recovery depends on the outcome of the measurements on the Computational basis (so we are performing Z measurements) of two external qubits:\n"},"Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Classical-Error-Correction":{"slug":"Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Classical-Error-Correction","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Classical Error Correction/Classical Error Correction.md","title":"Classical Error Correction","links":["Quantum-Information/Quantum-Error-Correction/Codes","Quantum-Information/Quantum-Computation/Classical-Computation/Hamming-Distance"],"tags":[],"content":"A nice summary on the subject can be found here.\nWe report some definitions here:\n\nConsider a an encoding which divides a message into chunks of length k bits, let’s call one of them x, which get sent into:\n\\mathcal{E}(x) = y\nwhere y is n bits long. This scheme is called code (see quantum Codes).\nA codeword is an element of the image of \\mathcal{E}.\nAn error is said to be detectable when, after the noise, the received bit message is not a codeword.\nAn error is said to be correctable when it is detectable and we can infer where the error occurred.\nThe distance d of the code is given by the minimum of the Hamming Distance between the codewords.\nThe rate of a code is given by R=k/n.\nA code that encodes k bits into n bits, with distance d is often denoted as a [n,k,d]-code.\n"},"Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Dual-codes":{"slug":"Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Dual-codes","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Classical Error Correction/Dual codes.md","title":"Dual codes","links":["Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Linear-codes"],"tags":[],"content":"Given a code \\mathcal{C}, with generator G and parity check matrix H\n#wip"},"Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Hamming-code":{"slug":"Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Hamming-code","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Classical Error Correction/Hamming code.md","title":"Hamming code","links":["Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Classical-Error-Correction","Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Linear-codes"],"tags":[],"content":"Hamming codes are codes which rely on parity checks to allow for error correction strategies.\nAn example of Hamming code is a [7,4,3]-code whose encoding of 4 bits abcd is:\nabcd\\overset{Hamming}{\\mapsto}abcdz_1z_2z_3\nwhere\nz_1 = a+b+d\nz_2 = a+d+c\nz_3 = d+b+c\nThis code allows for single bit-flip detection and correction, for example, if only the parity check z_3 is not violated, we can infer that the error happened in a.\nThe rate if this Hamming code is R = 4/7, which is already bigger than the 1/3 of the 3-bit repetition code while maintaining the same distance.\nLinear form\nHamming codes are Linear codes. For a [n,k,d], the generator matrix can be cast in the form\nG = \\left[\\begin{array}{c}\\mathbb{1}_k \\\\ \\hdashline A\\end{array}\\right]\nwhere \\mathbb{1}_k is the k\\times k is the k-dimensional identity matrix and A is a (n-k)\\times k matrix that performs parity checks. For the code given above, the generator matrix is:\nG=\\left(\\begin{array}{llll}\n1 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 1 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 1 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 1 \\\\\n\\hdashline 1 &amp; 1 &amp; 0 &amp; 1 \\\\\n1 &amp; 0 &amp; 1 &amp; 1 \\\\\n0 &amp; 1 &amp; 1 &amp; 1\n\\end{array}\\right)\nwhile the parity check matrix is:\nH = \\left(\\begin{array}{cccc:ccc}\n1&amp;1&amp;0&amp;1&amp;1&amp;0&amp;0\\\\\n1&amp;0&amp;1&amp;1&amp;0&amp;1&amp;0\\\\\n0&amp;1&amp;1&amp;1&amp;0&amp;0&amp;1\n\\end{array}\\right)"},"Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Linear-codes":{"slug":"Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Linear-codes","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Classical Error Correction/Linear codes.md","title":"Linear codes","links":["Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Classical-Error-Correction","Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Hamming-code","Bayes-Theorem","IID-process"],"tags":[],"content":"A linear code consists in a code (see Classical Error Correction) whose encoding relies on a linear transformation defined by a so called generator matrix G, which is k\\times n:\n\\mathcal{E}(x) \\equiv G x = y\nOf course, the matrix multiplication is performed modulo 2. The corresponding codewords are all the linear combinations of the columns of G.\nAn equivalent picture is given by the (n-k)\\times n parity-check matrix H, whose kernel defines all the codewords:\nH y =0\nThe intuition is that linear codes can always be defined as a set of codewords obeying a certain system of linear equations, defined by the parity checks.\nLinear codes are messages with parity checks\nElementary operations on generator matrices don’t change the code, which only depends on the image of G. Using gaussian reduction, it is always possible to cast G into the form given in Hamming codes.\nG = \\left[\\begin{array}{c}\\mathbb{1}_k \\\\ \\hdashline A\\end{array}\\right]\nIn other words, any linear code can be seen as a message supplemented with parity checks!\nParity check matrix\nLet’s go back to the parity-check matrix H:\nH y =0\nFor a generator matrix\nG = \\left[\\begin{array}{c}\\mathbb{1}_k \\\\ \\hdashline A\\end{array}\\right]\nthe corresponding parity check matrix is:\nH = \\left[\\begin{array}{c:c}A&amp;\\mathbb{1}_{n-k}\\end{array}\\right]\nIn fact, given that:\ny=G x= \\left[\\begin{array}{c}x \\\\ \\hdashline Ax\\end{array}\\right]\nthen (remember to perform operations modulo 2):\nHy = Ax + Ax = 0\nError syndrome\nIn the presence of an error:\n\\tilde{y} = y +e\nThe parity checks matrices provide a very useful tool to detect it:\nH\\tilde{y} = He\nThe vector s= He has dimension n-k and is called error syndrome; each of its components is equal to 1 if the corresponding parity check equation is violated.\nDecoding a message means identifying the most probable e which leads to the syndrome s.\nDecoding linear codes\nThe decoding process is a probabilistic one, as one error syndrome could correspond to multiple errors, the decoding task consists in finding the most probable one under the constraint:\ns = He\nBasically, under this constraint, we are maximizing the conditional probability P(e|s); employing Bayes Theorem:\nP(e|s)= \\frac{P(e|s)P(e)}{P(s)}\nP(s) does not depend explicitly on e, it can be forgotten during maximization. Furthermore, P(e|s) is 1 if the parity check equation is satisfied and 0 otherwise:\nP(e|s) = \\delta (s-He)\nTherefore, we only need to maximize P(e) while keeping P(e|s) =1.\n\\max_{e:\\,He =s}P(e)\nIf we suppose the errors to be IID processes, we can write the error probability as:\nP(e) = p^{\\abs{e}} (1-p) ^{n-\\abs{e}}\nwhere p is the probability of single bitflip and \\abs{e} is the Hamming weight of e.\n\n\n                  \n                  Hamming weight \n                  \n                \n\nIn a bit string, the Hamming weight corresponds to the amount of 1’s in the string\n\n\nIf our devices are decent enough, the bitflip probability is usually smaller than 0.5. In this case, the total error probability decreases when \\abs{e} increases. Therefore, the decoding problem becomes a minimization one:\n\\min_{e:\\,He =s}\\abs{e}\n\n\n                  \n                  MAP decoders \n                  \n                \n\nMaximum a priori decoders are decoding algorithms that rely on the considerations exposed above. Their name comes from dealing with a posteriori distribution P(e|s). These problems are NP-complete, so they are worth looking into.\n\n"},"Quantum-Information/Quantum-Error-Correction/Codes":{"slug":"Quantum-Information/Quantum-Error-Correction/Codes","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Codes.md","title":"Codes","links":["Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Foundations/Density-matrix-operators"],"tags":[],"content":"Consider a noisy channel \\mathcal{N}:\n\\mathcal{N}:\\sigma(\\mathcal{H}_A)\\mapsto \\sigma(\\mathcal{H}_B)\nWe define the code \\mathcal{H}_C the subspace of \\mathcal{H}_A such that:\n\\exists \\mathcal{D}\\textrm{ map}: \\forall \\rho \\in \\sigma\\left(\\mathcal{H}_C\\right), \\mathcal{D}\\circ\\mathcal{N} (\\rho)\\propto \\rho\nThat is, there exists a decoding map (it is not necessarily a channel because it does not need to be trace-preserving) capable of correcting the errors induced by \\mathcal{N} on the states belonging to the code."},"Quantum-Information/Quantum-Error-Correction/Color-codes":{"slug":"Quantum-Information/Quantum-Error-Correction/Color-codes","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Color codes.md","title":"Color codes","links":["tags/wip"],"tags":["wip"],"content":"wip"},"Quantum-Information/Quantum-Error-Correction/Generic-Error-Correction-module":{"slug":"Quantum-Information/Quantum-Error-Correction/Generic-Error-Correction-module","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Generic Error Correction module.md","title":"Generic Error Correction module","links":["Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Quantum-Error-Correction/Logical-qubits","Quantum-Information/Measurements/POVM's"],"tags":[],"content":"Consider the error induced by a quantum channel \\mathcal{N}. We try to correct the error through a gate sequence structured in the following form:\n\nThe map \\mathcal{N}\\circ\\mathcal{E} is the composition of encoding and noise; the map \\mathcal{D} represents the decoding; L indicates the logical qubit and A an auxiliary qubit. This structure follows from the POVM formalism.\nA possible modification of the QEC module exists where the measurement on the auxiliary qubit is not performed and the decoding gate is controlled by A at the quantum mechanical level:\n\n\\mathcal{D} \\equiv \\sum _k \\ket{k}_A\\bra{k}\\otimes\\mathcal{D}_k"},"Quantum-Information/Quantum-Error-Correction/Knill-Laflamme-theorem":{"slug":"Quantum-Information/Quantum-Error-Correction/Knill-Laflamme-theorem","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Knill-Laflamme theorem.md","title":"Knill-Laflamme theorem","links":["Quantum-Information/Quantum-Error-Correction/Quantum-Error-Correction-(QEC)","Quantum-Information/Open-system-dynamics/Quantum-channels","Quantum-Information/Quantum-Error-Correction/Codes","Quantum-Information/Open-system-dynamics/Quantum-channel-representations","Quantum-Information/Foundations/Orthogonality-relation-for-unitaries","Quantum-Information/Open-system-dynamics/Kraus-representation-equivalence","Quantum-Information/Foundations/Polar-decomposition"],"tags":[],"content":"The Knill-Laflamme theorem provides us with a sufficient and necessary condition for error correction.\nGiven a channel \\mathcal{N} and a code \\mathcal{H}_C:\n\\mathcal{H}_C \\textrm{ corrects } \\mathcal{N}\\Leftrightarrow\\exists \\alpha _{mn} \\textrm{ hermitian}: PK_i^\\dagger K_jP =\\alpha _{ij} P\nwhere P is the projector on \\mathcal{H}_C and the K_i‘s are the Kraus operators of the channel.\nProof\n\\Leftarrow\nFirst we show that \\alpha is hermitian by taking the adjoint of PK_i^\\dagger K_jP =\\alpha _{ij} P:\nPK_j^\\dagger K_iP =\\alpha _{ij} ^* P\nPK_i^\\dagger K_jP =\\alpha _{ji} ^* P\n\\alpha _{ij} = \\alpha _{ji} ^*\nAlso, \\alpha \\geq 0 must hold, which means \\vec{v} ^T\\alpha \\vec{v} \\geq 0 \\forall v. We prove this by contracting the Knill-Laflamme condition with v:\n\\sum_{ij}v^*_i v_j PK_i^\\dagger K_jP =\\sum_{ij}v^*_i v_j\\alpha _{ij} P\nDefine \\Theta \\equiv \\sum _i v_i K_i, the operator \\Theta^\\dagger\\Theta is positive, and so must be P\\Theta^\\dagger\\Theta P, therefore the left-hand side is positive. The right hand side is a projector (positive) multiplied by \\vec{v} ^T\\alpha \\vec{v}, therefore this coefficient must be positive \\Rightarrow \\alpha \\geq 0.\nNow, we can diagonalize \\alpha, the eigenvalues d_{ll} will be non negative:\n\\alpha_{ij} = \\sum _{l} V_{il} d_{ll}V^*_{jl}\nwhere the V_{il} are the elements of a unitary matrix\nPK_i^\\dagger K_jP =\\sum _{l} V_{il} d_{ll}V^*_{jl} P\nUsing the Orthogonality relation for unitaries:\n\\sum_l V_{il} V^*_{jl} =\\sum_l V_{li} V^*_{lj} = \\delta_{ij}\nWe can take the sum\n\\sum_{ij} V_{jn} V^*_{im}\nand multiply each element by the Knill-Laflamme conditions (which holds element-wise):\n\\sum_{ij} V_{jn} V^*_{im} PK^\\dagger _iK_j P= \\sum _{l,i,j} V_{jn} V^*_{im}V_{il} d_{ll}V^*_{jl} P\nOn the left side we define F_m \\equiv \\sum _i V_{im} K_i; on the right side we use the orthogonality relations:\nPF^\\dagger_i F _j P = \\delta_{ij}d_{ii}P\nBy the Kraus representation equivalence, the F_i‘s are a Kraus set of the channel (transpose of a unitary is still unitary), therefore an equivalent condition to the initial one is\nPF^\\dagger_i F _j P = \\delta_{ij}d_{ii}P\nNow we define the decoding explicitly.\n\nClaim: \\exists U_i unitary s.t.\nF_i P = \\sqrt{d_{ii}} U_i P\n\n\nThis is a consequence of Polar decomposition:\n  F_i P = U_i \\sqrt{P F_i ^\\dagger F_i P}\nsubstitute the Knill-Laflamme condition and note that the square root of a projector is the projector itself. This U_i will be used in the decoding\n\nDefine\n\nP_i \\equiv U_i P U_i ^\\dagger\nP_i is itself a projector\n  P_i P_j = \\delta _{ij}P_i\n  \nThis can easily proven directly if d_{ii}&gt;0. The general \\geq case can still be proven but it’s very technical.\n\nThe P_i identify orthogonal subspaces in the original input space (these subspaces are not necessarily orthogonal to the code). The decoding will send elements of the code in one of these subspaces, which can be recognized separately. Afterwards, recovery can be achieved.\nDefine the decoding channel from its Kraus set\n\n  \\mathcal{D} (\\theta) = \\sum _ i N_i \\theta N_i ^\\dagger\n  \n  N_i \\equiv U_i ^\\dagger P _i\n  \nNoting that, \\forall \\rho \\in \\sigma(\\mathcal{H}_C), P\\rho P = \\rho, the composition of noise and decoding is:\n  \\begin{split}\\mathcal{D}\\circ\\mathcal{N}(\\rho) = &amp; \\sum_{ij}N_i F_j\\rho F^\\dagger _j N^\\dagger_i = \\sum_{ij}N_i F_j P \\rho P F^\\dagger _j N^\\dagger_i \\\\= &amp; \\sum_{ij}N_i \\sqrt{d_{jj}} U_j  P \\rho  P \\sqrt{d_{jj}} U_j ^\\dagger N^\\dagger_i\\\\= &amp; \\sum_{ij}d_{jj}U_i ^\\dagger P _i   U_j  P U_j ^\\dagger U_j\\rho  U_j^\\dagger U_jP  U_j ^\\dagger  P _i U_i \\\\= &amp; \\sum_{ij}d_{jj}U_i ^\\dagger P _i P_j  U_j \\rho  U_j ^\\dagger P_j P _i U_i \\\\ \\propto &amp; \\rho\\end{split}\n  \n\\Rightarrow\nSuppose \\mathcal{H}_C corrects \\mathcal{N} and call P the projectors onto \\mathcal{H}_C. Then \\exists \\mathcal{D}:\n\\mathcal{D}\\circ\\mathcal{N}(P\\rho P) \\propto P\\rho P\nfor all \\rho \\in\\sigma(\\mathcal{H}_A); since both sides of this relation are linear, the proportionality constant c must not depend on \\rho:\n\\mathcal{D}\\circ\\mathcal{N}(P\\rho P) = c P\\rho P\nGiven the Kraus sets \\{K_i\\}_i, \\{N_i\\}_i of \\mathcal{N}, \\mathcal{D}, respectively, this becomes:\n\\sum_{ij} N_i K_j P\\rho P K_j ^\\dagger N_i ^\\dagger = cP\\rho P\nThis last equation implies that the channel \\mathcal{D}\\circ\\mathcal{N}\\circ \\mathcal{P} (\\mathcal{P} is the projector channel), with Kraus elements N_i K_j P, produces the same output as the channel \\sqrt{c}\\mathcal{P}, with the single Kraus operator \\sqrt{c} P. Invoking the Kraus representation equivalence, \\exists a complex number c_{ij} such that:\nN_i K_j P = c _{ij}P\nWe can then take the adjoint of this equation and contract it with the equation itself:\nPK ^\\dagger _j N^\\dagger _lN_l K_i P = c _{lj}c^* _{li}P\nSince \\mathcal{N} is trace-preserving, \\sum _l N^\\dagger _lN_l =\\id; we sum the equation above over l:\nPK ^\\dagger _j K_i P = \\sum _l c _{lj}c^* _{li}P \\equiv \\alpha_{ji}P\nwhere\n\\alpha _{ij} \\equiv \\sum _l c _{li}c^* _{lj}\nIs \\alpha _{ij} hermitian and positive semi-definite?\n\\alpha _{ji} ^* = \\sum _l c^* _{lj}c _{li} = \\alpha_{ij}\n\\sum_{ij}v_i\\alpha _{ij}v_j \\equiv \\sum _{ijl} v_i c _{li}c^* _{lj}v_j \\geq 0"},"Quantum-Information/Quantum-Error-Correction/Logical-qubits":{"slug":"Quantum-Information/Quantum-Error-Correction/Logical-qubits","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Logical qubits.md","title":"Logical qubits","links":["Quantum-Information/Quantum-Error-Correction/Quantum-Error-Correction-(QEC)","Quantum-Information/Foundations/Qubits","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code"],"tags":[],"content":"In the presence of noise (see Quantum Error Correction (QEC)), we can overcome possible errors by encoding the information contained in a single qubit \\ket{\\psi}:\n\\ket{\\psi} = \\alpha \\ket{0}+ \\beta\\ket{1}\ninto multiple qubits. Consider n qubits (which are called physical qubits) and a generic state of the system \\ket{\\Omega}:\n\\ket{\\Omega}\\in\\mathcal{H}_2^{\\otimes n}\n\\mathcal{H}_2^{\\otimes n} has dimension 2^n; then we call logical qubits the states in this space which lie in a 2-dimensional hyperplane \\mathcal{H}_L:\n\\ket{\\psi}_L \\in \\mathcal{H}_L\\subset \\mathcal{H} _2 ^{\\otimes n}\nUsually, we take the basis of \\mathcal{H}_L to be \\left\\{\\ket{0}^{\\otimes n},\\ket{1}^{\\otimes n}\\right\\}, so that:\n\\ket{\\psi}_L = \\alpha \\ket{0}^{\\otimes n}+ \\beta\\ket{1}^{\\otimes n}\nThe idea is that the noise induced on \\mathcal{H}_L will have a lesser impact than the one on \\mathcal{H}_2.\nStabilizer formalism\nIn the context of stabilizer codes, we can find the number of logical qubits from the number of generators of the stabilizer group.\nThe code (space) \\mathcal{C} can be identified with the space spanned by the corresponding logical qubits, e.g., if we have:\n\\vert \\psi \\rangle_L = a_1 \\vert a_1\\rangle + a_2 \\vert a_2\\rangle + a_3 \\vert a_3\\rangle + a_4 \\vert a_4\\rangle\nthen we can relabel \\vert a_1\\rangle as \\vert 00\\rangle_L, \\vert a_2\\rangle as \\vert 01\\rangle_L, etc.\nHow many logical qubits correspond to the code \\mathcal{C}? Easy, it’s the log base 2 of the dimension of \\mathcal{C}:\n\\#\\textrm{ logical qubits} = \\logbit\\left(\\dim (\\mathcal{C})\\right)\n\n\n                  \n                  Number of logical qubits \n                  \n                \n\nFor a stabilizer code \\mathcal{C}, if we are encoding n physical qubits and the code has m generators for the corresponding stabilizer group \\mathcal{S} the number of logical qubits is given by:\n\\dim (\\mathcal{C}) = 2^{n-m}\n\\#\\textrm{ logical qubits} = n-m\n\n\n                  \n                  Proof \n                  \n                \n\n\\Pi_{\\mathcal{C}}=\\frac{1}{2^m} \\prod_{i=0}^{m-1}(1-S_i),\nwhere S_i are the independent elements of the stabilizer group (it’s easy to prove that this object is the correct projector). This can be rewritten as\n\\Pi_{\\mathcal{C}}=\\frac{1}{2^m}\\sum_{S \\in \\mathcal{S}} S\nfrom which it’s easy to show that \\tr \\left(\\Pi_{\\mathcal{C}}\\right) =\\dim (\\mathcal{C}) and \\tr \\left(\\Pi_{\\mathcal{C}}\\right) = 2^{n-m}\n\n\n\n"},"Quantum-Information/Quantum-Error-Correction/Phase-flip-error---3-qubits":{"slug":"Quantum-Information/Quantum-Error-Correction/Phase-flip-error---3-qubits","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Phase-flip error - 3 qubits.md","title":"Phase-flip error - 3 qubits","links":["Quantum-Information/Foundations/Qubits","Quantum-Information/Notable-channels/Dephasing-channel","Quantum-Information/Quantum-Error-Correction/Bit-flip-error---3-qubits","Quantum-Information/Quantum-Computation/Hadamard-Gate","Quantum-Information/Quantum-Error-Correction/Logical-qubits","Quantum-Information/Quantum-Computation/Computational-basis"],"tags":[],"content":"Consider that the source of noise on the Qubits in a machine induces an unwanted phase-flip transformation:\n\\mathcal{D}(\\rho) = (1-p)\\rho +p Z\\rho Z, \\quad p\\in[0,1]\nThis error can be treated in a similar way as the one in Bit-flip error - 3 qubits, as the dephasing channel can be mapped into a bit-flip channel through Hadamard Gates.\nEncoding\n\nGiven a state\n\\ket{\\psi} = \\alpha \\ket{0} +\\beta \\ket{1}\nwe need to encode \\alpha,\\beta in 3 qubits. This can be achieved through entanglement:\n\\ket{\\psi}_L = \\alpha\\ket{+++} +\\beta\\ket{---} \\equiv\\alpha \\ket{+}_L +\\beta \\ket{-}_L\n\\ket{\\psi}_L is the logical qubit of our encoding, which can be produced through the procedure depicted in the figure above.\nThe same reasoning of the partition of the Hilbert space discussed for the bit-flip 3 qubit error correction can be done here, substituting 0 with + and 1 with -.\nError syndrome measurement\nThe error correcting procedure works as depicted:\n\nAnd the recovery depends on the outcome of the measurements on the Computational basis of two external qubits:\n"},"Quantum-Information/Quantum-Error-Correction/Quantum-Error-Correction-(QEC)":{"slug":"Quantum-Information/Quantum-Error-Correction/Quantum-Error-Correction-(QEC)","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Quantum Error Correction (QEC).md","title":"Quantum Error Correction (QEC)","links":["Quantum-Information/Quantum-Computation/One-qubit-gates","Quantum-Information/Quantum-Computation/Two-qubit-gates","Quantum-Information/Quantum-Error-Correction/3-qubits-code","Quantum-Information/Quantum-Error-Correction/9-qubits-code-(Shor's-code)","Quantum-Information/Quantum-Error-Correction/Generic-Error-Correction-module","Quantum-Information/Quantum-Error-Correction/Knill-Laflamme-theorem"],"tags":[],"content":"In the real world, the perfect gates treated in One qubit gates and Two qubit gates do not exist. There will always be a certain amount of noise, which will need to be dealt with.\nA usual assumption about the noise is that it is a IID (Independent and Identically Distributed) process.\nSince noise is a stochastic process, a possible solution to it would be redundancy. There are encodings which allow to store the value of a qubit into multiple qubits.\n\n3 qubits code\n9 qubits code (Shor’s code)\nThe main structure of QEC can be found in Generic Error Correction module\nThere exists a theorem that formalizes whether QEC is possible or not: Knill-Laflamme theorem\n"},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Binary-symplectic-format":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Binary-symplectic-format","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Binary symplectic format.md","title":"Binary symplectic format","links":["Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Quantum-Error-Correction/Quantum-Error-Correction-(QEC)","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","Group-Theory/Symplectic-matrix"],"tags":[],"content":"It is possible to perform a mapping between Pauli operators and two bit words:\n\\begin{aligned} (0\\vert0) &amp; \\leftrightarrow I \\\\ (1\\vert0) &amp; \\leftrightarrow X \\\\ (0\\vert1) &amp; \\leftrightarrow Z \\\\ (1\\vert1) &amp; \\leftrightarrow Y \\end{aligned}\nso that a generic Pauli operator (up to a phase) is represented by:\n(x \\vert z) \\leftrightarrow X^{x} Z^{z}\nIn the context of QEC, we do not need the additional two bits that would be required to encode the phase (although there are some applications where that may be useful, e.g. the stabilizer tableau method), see here.\nIn the case of a tensor product of Pauli’s:\nP=\\bigotimes _{i = 0} ^{n-1} P_i\nP\\leftrightarrow\\begin{aligned} (x_i \\vert z_i) \\equiv \\underline{l} \\end{aligned}\nSymplectic sum\nUnder this formalism, matrix multiplication becomes a sum modulo 2 of the symplectic vectors:\nP_1 = (x_1 | z_1) = \\underline{l}_1, \\quad P_2 = (x_2 | z_2)=\\underline{l}_2\nP_1P_2 = (x_1+x_2 | z_1+z_2) = \\underline{l}_1 + \\underline{l}_2\nAgain, Pauli operators either commute or anticommute, so this sum automatically selects the corresponding Pauli operator with a +1 global phase.\nSymplectic product\nAnother meaningful operation that can be performed in this formalism is the symplectic product, which is defined through the Symplectic matrix:\n\\Omega = \\left( \\begin{matrix} 0 &amp; \\id_n \\\\ \\id_n &amp; 0 \\end{matrix} \\right)\nThe symplectic product of two symplectic vectors is:\n\\underline{l}_1 \\odot \\underline{l}_2 \\equiv \\underline{l}_1 \\Omega \\underline{l}_2 ^T\nGiven two m \\times 2n matrices A,B, we can also define their symplectic product:\nA\\odot B = A\\Omega B^T\nWhich means that the (i,j) element of the product is the symplectic product of the i-th row of the A matrix and the j-th row of the B matrix.\nThe symplectic product relates to the commutator of two Pauli operators; two Pauli operators commute if their binary symplectic product is 0, and anticommute if it is 1. To see this, notice that\nx_i z&#039;_i + z_i x&#039;_i\nis equal to 1 if and only if there is an\nX and a Z intersecting on qubit i, but not a Y on both (which would give 2, or 0 modulo 2).\nRecap\n\nSymplectic sum \\leftrightarrow Operator product\nSymplectic product \\leftrightarrow Commutator\n"},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/CSS-code":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/CSS-code","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/CSS code.md","title":"CSS code","links":["Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Classical-Error-Correction","Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Linear-codes","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Steane-code","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Parity-check-matrix"],"tags":[],"content":"A Calderbank-Shor-Steane (CSS) code is a Stabilizer code that can be generated by a set of pure X and pure Z stabilizers. They can be built starting from classical codes (see Classical Error Correction for a quick review).\nWe can convert classical codes starting from their parity checks (you can think of X errors “classically” by considering them as bitflips in the \\ket{\\pm} basis). Therefore, consider the X,Z classical parity checks in the codes C_X,C_Z (i.e. the rows of the parity check matrix), supported on a subset of our qubits (“converted” in bits). If C_X has support on the bits b_1,...,b_k, add the stabilizer X_1,...X_k to the stabilizer group; do the same for C_Z. At the end we need to check that all the elements of the stabilizer groups commute with each other. Since stabilizer codes are a subgroup of the Pauli group and Pauli operators either commute or anticommute (see Pauli algebra), we basically need to check, for every pair of elements in the group, on how many qubits one element has an X operator while the other has a Z operator. If this number is even for every pair, then all the elements of the group commute, while if for a pair the number is odd, that means that those two elements anticommute and need to be excluded from the stabilizer group.\nWhile conceptually simple, this construction with some random parity checks taken from classical literature result in an “abelian test” that is very difficult to pass. Therefore, more involved methods are needed to construct quantum codes, such as topological constructions or hypergraph products. An example where this more convoluted tools are not necessary is the Steane code, which is the quantum equivalent of the Hamming code.\nParity checks\nFor CSS codes, the Parity check matrix can be written as\n \\begin{aligned} \\bf{H} = \\left( \\begin{matrix} H_X &amp; \\vert &amp; \\bf{0} \\\\ \\bf{0} &amp; \\vert &amp; H_Z \\end{matrix} \\right) \\end{aligned}\nwhere H_X and H_Z are the parity-check matrices of the two classical codes C_X and C_Z.\nFor CSS codes, the parity check matrix condition reduces to:\nH_X H_Z ^T =0\nThis constraint is what makes it hard to design quantum codes by using classical constructions: most classical codes don’t satisfy this property."},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Decoding-in-stabilizer-codes":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Decoding-in-stabilizer-codes","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Decoding in stabilizer codes.md","title":"Decoding in stabilizer codes","links":["Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Linear-codes","Quantum-Information/Quantum-Computation/Classical-Computation/Classical-computation","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Syndromes","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Binary-symplectic-format","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Parity-check-matrix","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-cosets","Group-Theory/Quotient-set"],"tags":[],"content":"Following a straightforward comparison with Linear codes in Classical computation, we may conclude that, for stabilizer codes, given an error syndrome in Binary symplectic format \\underline{s} corresponding to a detectable error \\underline{e} and a Parity check matrix H so that:\nH\\odot\\underline{e} = \\underline{s}\nthe error correcting operator \\underline{c} that we need to apply to correct the error \\underline{e} is found through:\n\\max_{\\underline{c} \\in \\mathbb{Z}_2^{2n}} P(\\underline{c}) \\; \\text{ s.t. } \\; H \\odot \\underline{c} = \\underline{s}\nThis corresponds to finding the error \\underline{c} that fits the syndrome and has the highest probability of happening. However, a refinement may be applied here.\nConsider a stabilizer S\\in \\mathcal{S} and its symplectic form \\underline{l},\nS\\leftrightarrow \\underline{l},\nThen, if for some \\underline{c}, H \\odot \\underline{c} = \\underline{s} is satisfied, we would also have:\nH \\odot (\\underline{c}+\\underline{l}) = \\underline{s}\nand, of course:\nH \\odot (\\underline{c}+\\underline{l}+\\underline{e}) = 0\nThen, it might be “logical” (hehe) to shift our attention to the Logical cosets instead of focusing on specific correction operators.\nWe denote the logical coset of the correction operator \\underline{c} as:\n\\underline{c}\\leftrightarrow[\\underline{c}]\nthen, we call \\mathcal{E}_{\\underline{s}} the set of logical Pauli’s that fit the syndrome \\underline{s} and\n\\mathcal{E}_{\\underline{s}} / \\mathcal{S}\nthe corresponding Quotient set. We can then rephrase the decoding problem as:\n\\max_{[\\underline{c}] \\in \\mathcal{E}_{\\bf{s}} / \\mathcal{S}} P([\\underline{c}])\nwhere\nP([\\underline{c}]) = \\sum _{\\underline{c}\\in[\\underline{c}]}P(\\underline{c})\nFor many codes, it’s possible to find syndromes where those two versions of the decoding problem give a different solution. This will be the case when the coset containing the most likely error have much less elements than another coset which contain slightly less likely errors. However, in practice, the two decoding problems often have the same solution, and many practical decoders only seek to solve the first optimization problem. This often results in a small decrease of performance, for a high gain in speed."},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-cosets":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-cosets","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Logical cosets.md","title":"Logical cosets","links":["Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Steane-code","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-gates","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","Quantum-Information/Quantum-Error-Correction/Codes","Group-Theory/Equivalence-class","Group-Theory/Quotient-set"],"tags":[],"content":"In Steane code we have seen an example of how to define logical X,Z operators. However, there will often be multiple logical operators that act as a given Pauli. Indeed, take a logical operator L\\in N(\\mathcal{S}) and a stabilizer S\\in\\mathcal{S}. Then LS is also a logical operator which acts in the same way on the codespace:\nL S \\vert \\psi \\rangle = L \\vert \\psi \\rangle\nMore over, there exists S&#039;\\in\\mathcal{S} s.t. LS = S&#039;L, so that\nLS\\ket{\\psi} = L\\ket{\\psi} = S&#039;L\\ket{\\psi}\nIn other words, applying a stabilizer to a logical doesn’t change the way it acts on the codespace. We say that two logicals L and L&#039; are equivalent if they only differ by a stabilizer, that is, if there exists S \\in \\mathcal{S} such that SL=L&#039;.\nSince all the equivalent logicals act in the same way on the codespace, it makes sense to group them together in some ways. The notion of Equivalence class is exactly what we need to formalize this idea.\nAn equivalence class, or coset, is a set of the form\n[L]=L\\mathcal{S}=\\{ LS : S \\in \\mathcal{S} \\}\nwhere L \\in N(\\mathcal{S}) is any logical operator. In other words, a coset is a set of equivalent logicals. Any element P \\in \\bar{L} is called a representative of the coset \\bar{L}.\nQuotient group\nLet’s remember a few important properties of equivalence classes. First of all, they partition the set of logical operators, that is, they are all disjoint (i.e. have an empty intersection) and their union is the whole set.\nSecondly, the set of all the cosets form a group, which is called the quotient group (see Quotient set) of N(\\mathcal{S}) by \\mathcal{S}, and denoted N(\\mathcal{S}) / \\mathcal{S}. In this group, the multiplication between two cosets [L_1]=L_1 \\mathcal{S} and [L_2]=L_2 \\mathcal{S} is defined as L_1 L_2 \\mathcal{S}, where L_1 and L_2 are two arbitrary representatives of [L_1], [L_2].\nFinally, the quotient group can be generated by all the [X_i],[Z_i]. We can extrapolate this to conclude that the number of logical qubits is exactly half the number of generators of N(\\mathcal{S}) /\\mathcal{S}. This simple fact gives us a different way to count the number of logical qubits of a given stabilizer code, which will become extremely important when discussing topological quantum error correction.\n#wip"},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-gates":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-gates","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Logical gates.md","title":"Logical gates","links":["Quantum-Information/Quantum-Error-Correction/Codes","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","Group-Theory/Normalizer","Quantum-Information/Foundations/Pauli-operators","Group-Theory/Centralizer","Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Classical-Error-Correction"],"tags":[],"content":"A logical gate is a unitary operator L that maps the codespace \\mathcal{C} into itself, i.e. such that L \\vert \\psi \\rangle \\in \\mathcal{C} for all \\vert \\psi \\rangle \\in \\mathcal{C}.\nIn the context of stabilizer codes, with stabilizer group \\mathcal{S}, logical gates include stabilizers, but also operators that map one part of the codespace to another part.\nThey can also be thought as elements of the Normalizer of S.\n\n\n                  \n                  Logical gates \n                  \n                \n\nA unitary L is a logical gate if and only if it maps the stabilizer group \\mathcal{S} to itself, i.e. L^{\\dagger} SL \\in \\mathcal{S} for all S \\in \\mathcal{S}.\n\n\nUsing this condition, it is possible to check whether operators are logical gates.\nPauli logicals\nAn important family of logical gates are the Pauli logical operators. As expected, those are the logical gates that belong to the Pauli group. As two given Pauli operators can either commute or anticommute, Pauli logicals could either commute or anticommute with stabilizers. However, if a Pauli logical anticommute with a stabilizer, that is SL=-LS, it means that L^{\\dagger} S L = -S \\notin \\mathcal{S}, which contradicts the characterization of logical gates given above. Therefore:\n\n\n                  \n                  Pauli logicals \n                  \n                \n\nA Pauli operator P is a logical operator if and only if it commutes with all the stabilizers.\n\n\nNotably, this means that Pauli logicals form the Centralizer {C}_{\\mathcal{P}_n}(\\mathcal{S}) of the stabilizer group, which itself is a subgroup of the Pauli group \\mathcal{P}_n.\nLogical errors\nLet’s define non-trivial logical operators (also known as logical errors) as elements of \\mathcal{C}(\\mathcal{S}) \\backslash \\mathcal{S}, or in other words, Pauli operators that commute with all the stabilizers but are not stabilizers themselves.\nNote that this means that logical errors send elements of the codespace into different elements of the codespace:\nSL\\ket{\\psi} = LS\\ket{\\psi} = L\\ket{\\psi}\nWith this notion we can define the distance (compare with Classical Error Correction) of a stabilizer code as the weight of the smallest logical error, which relates to the minimum distance between different codewords:\nd \\equiv \\min _{L\\in \\mathcal{C}(\\mathcal{S}) \\backslash \\mathcal{S}} \\abs{L}"},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Minimal-1-qubit-error-code":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Minimal-1-qubit-error-code","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Minimal 1 qubit error code.md","title":"Minimal 1 qubit error code","links":["Quantum-Information/Quantum-Error-Correction/9-qubits-code-(Shor's-code)","Quantum-Information/Quantum-Error-Correction/Codes","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Parity-check-matrix"],"tags":[],"content":"Shor’s code is not the minimal code that is able to correct 1 qubit errors. In fact, we can construct the following stabilizer code:\n\\begin{matrix}\nX &amp; Z &amp; Z &amp; X &amp; \\mathbb{1}_2\\\\\n\\mathbb{1}_2 &amp; X &amp; Z &amp; Z &amp; X\\\\\nX &amp; \\mathbb{1}_2 &amp; X &amp; Z &amp; Z\\\\\nZ &amp; X &amp; \\mathbb{1}_2 &amp; X &amp; Z\\\\\n\\end{matrix}\nwhich is able to correct any 1-qubit error.\nParity check matrix\nThe Parity check matrix of the code is given by:\nH = \\left(\\begin{array}{ccccc|ccccc}\n1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\\\\n0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\\\\n1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\\\\n0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\\\\n\\end{array}\\right)"},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Parity-check-matrix":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Parity-check-matrix","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Parity check matrix.md","title":"Parity check matrix","links":["Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Linear-codes","Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Classical-Error-Correction","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Binary-symplectic-format","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-gates","Group-Theory/Centralizer","tags/wip"],"tags":["wip"],"content":"In Linear codes for Classical Error Correction, the concept of parity matrices was introduced. These objects can be translated to the Stabilizer code formalism.\nLet \\mathcal{S} be a stabilizer group whose generator set \\left\\{S_i\\right\\} has m elements and which acts on n physical qubits; then we can define the quantum parity check matrix H as a m\\times 2n matrix where each row is a stabilizer generator written in the Binary symplectic format.\nS_i \\leftrightarrow \\underline{l}_i\nH \\equiv \\begin{pmatrix}...\\\\\\underline{l}_i\\\\...\\end{pmatrix}\nFor any valid stabilizer code, the parity check matrix must satisfy:\nH\\odot H = 0\nThis is due to the fact that all stabilizer generators must commute.\nThe topological interpretation of this constraint (as a chain complex) explains the wide intersection between topology and quantum error correction, which doesn’t arise classically.\nKernel\nThe kernel of the parity check matrix is the set of Pauli logicals in binary symplectic form. Indeed this set consists of all the Pauli operators which commute with the stabilizers (i.e. the Centralizer {C}_{\\mathcal{P}_n}(\\mathcal{S})).\nThe concept of codewords x found in linear codes is then replaced by that of Pauli logicals \\underline{x}:\nH\\odot\\underline{x} = 0\nThis gives us a systematic method to find the logical errors of a given a code. Find a basis for the kernel of H and keep all the elements that cannot be written as linear combinations of rows of H (the stabilizers).\nwip"},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Stabilizer code.md","title":"Stabilizer code","links":["Quantum-Information/Foundations/Pauli-operators","Group-Theory/Abelian-group","Group-Theory/Subgroup","Quantum-Information/Quantum-Error-Correction/Codes","Quantum-Information/Quantum-Error-Correction/9-qubits-code-(Shor's-code)","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/CSS-code","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Steane-code","Quantum-Information/Quantum-Error-Correction/Logical-qubits","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-cosets","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-gates","tags/wip"],"tags":["wip"],"content":"The main idea behind stabilizer codes consists in shifting the focus from the vector space (codewords) to the operator space.\nConsider the Pauli group\n\\mathcal{P}_n\\equiv \\left\\{\\omega \\bigotimes_{i=0}^{n-1}P_i: \\omega \\in\\left\\{1,-1,i,-i\\right\\}\\right\\}\nwe define a stabilizer group \\mathcal{S} as any abelian subgroup of the Pauli group which doesn’t contain the element -\\mathrm{Id}.\nWe therefore define the stabilizer code \\mathcal{C} as:\n\\mathcal{C} \\equiv \\left\\{\\ket{\\psi}: S\\ket{\\psi}=\\ket{\\psi}, \\forall S \\in\\mathcal{S}\\right\\}\nnote how the requirement that \\mathcal{S} does not admit -\\mathrm{Id} suddenly makes sense. Each stabilizer admits at least an eigenvalue +1, meaning that there is a common eigenvalue +1 for all stabilizers. The stabilizer code forms a vector space, therefore it is a valid code.\nPhases\nThe possibility of having a global phase \\omega different than +1 is just a formal one. In practice, Pauli elements with a phase of \\pm i, other than being anti-hermitian, would square to -\\id, so they can’t be included in the stabilizer group. Moreover, if a stabilizer S_i has a phase -1, it can be replaced by -S_i without changing any property of the code. Therefore, we can safely only consider stabilizers whose phase is +1.\nError syndrome\nIf no error occurs, measurements associated to the stabilizer group on the state would output +1. Consider instead the possibility that a Pauli error E has occurred; given S\\in \\mathcal{S}, E either commutes or anticommutes with S (see Pauli algebra):\nSE\\ket{\\psi} = \\pm E\\ket{\\psi}\nGenerally speaking, we can detect an error if the measurement is -1; when this happens, it means that the error and the stabilizer share an odd number of qubits where one operator acts with X and the other with Z.\nSo, in this case, to detect X errors we would need the stabilizer to have Y or Z where the error occurred, while to detect Z errors out stabilizer would need Y,X. The nice thing about error correction in this framework is that to correct errors we need to find an operator C such that:\nCE\\ket{\\psi} = \\ket{\\psi}\nIn other words, CE is a stabilizer. It can be useful to compare these notions with Shor’s code, where even though we don’t know where the error occurs, we can still correct it.\nHow to build stabilizer codes\nCSS codes\nAn easy way for generating stabilizer codes comes from CSS codes, which are basically quantum version of classical codes; an example of CSS codes is the Steane code.\nGeneric preparation\nDefine logical quibits from stabilizer, see what they correspond to in terms of logical qubits, design preparation\nCode specs\nWe can write the specifics of a stabilizer code in the [n,k,d]-format using:\n\nn is the number of physical qubits\nk is the number of logical qubits, which can be obtained either by knowing the number m, in which case we have:\n\\#\\textrm{ logical qubits} = n-m\nor by the number of generators of the quotient group of the code, in which case the number of logical qubits is half the number of generators\nd is the distance of the code, obtained as the minimum weight of all possible logical errors:\nd \\equiv \\min _{L\\in \\mathcal{C}(\\mathcal{S}) \\backslash \\mathcal{S}} \\abs{L}\n\n\nwip"},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Steane-code":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Steane-code","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Steane code.md","title":"Steane code","links":["Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/CSS-code","Quantum-Information/Quantum-Error-Correction/Classical-Error-Correction/Hamming-code","Quantum-Information/Quantum-Error-Correction/Color-codes","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-cosets","Group-Theory/Equivalence-class","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Parity-check-matrix","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Decoding-in-stabilizer-codes","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Tanner-graphs"],"tags":[],"content":"The Steane code is obtained by applying the CSS code procedure to the [7,4,3]-Hamming code.\nThe classical parity checks are:\nx_0+x_1+x_3+x_4=0\nx_0+x_2+x_3+x_5=0\nx_1+x_2+x_3+x_6=0\nFollowing the CSS procedure, we obtain a stabilizer group associated to the two sets:\n\\mathcal{S}_X = \\left\\{X_0X_1X_3X_4,X_0X_2X_3X_5,X_1X_2X_3X_6\\right\\},\n\\mathcal{S}_Z = \\left\\{Z_0Z_1Z_3Z_4,Z_0Z_2Z_3Z_5,Z_1Z_2Z_3Z_6\\right\\},\n\\mathcal{S}=\\mathcal{S}_X\\cup\\mathcal{S}_Z\nWe would need to check if the elements of \\mathcal{S} commute. Of course we only need to cross-check the elements in \\mathcal{S}_X and \\mathcal{S}_Z. We can employ a useful graphical representation:\n\nEach node represents a qubit while each colored section (often called plaquette) represents a stabilizer. Explicitly for X:\n\nThe same can be done for Z. Note that different stabilizers “intersect” on an even number of qubits, therefore all the elements of \\mathcal{S} commute.\nThe Steane code is an example of Color codes.\nLogical qubits\nUsing the logical qubits result for stabilizer codes, we find that for the Steane code we have:\n\\# \\textrm{ logical qubits} = 7-6=1\nDistance\nWe define the following operators, called X_L and Z_L:\n\nThese operators are logical errors for the stabilizer code.\nIndeed, it is easy to check that they commute with all the stabilizers, as they share either zero or two qubits with every plaquette. Moreover, by trying all the combinations of stabilizers, you can show that they don’t belong the stabilizer group, and are therefore non-trivial. By using a similar brute-force search, you can also show that they are the smallest non-trivial logical operators, thereby proving that the distance of the Steane code is d=3. This achieves the proof that the Steane code is a [[7,1,3]] code.\nIt can also be shown that these operators act as logical X,Z operators by choosing the states \\ket{0}_L,\\ket{1}_L to be the eigenstates of X_L and the states \\ket{+}_L,\\ket{-}_L to be the eigenstates of Z_L; given that the two errors anticommute this choice is valid and also fixes Y_L = X_LZ_L. Using this convention, it is possible to prove that H_L = H^{\\otimes 7} acts as the logical Hadamard.\nLogical cosets\nAs an example of the Logical cosets we can consider various representative of the logical X_L defined above\n\nTo go from the first one to the second one, we apply a green X plaquette (stabilizer). To go from the second one to the last one, we apply a red X plaquette. Since the Steane code has only one qubit, all the X logicals are equivalent and there is only one coset of X logicals.\nGiven that cosets partition the set (see Equivalence class), we have that:\nN(\\mathcal{S}) =[I] \\cup [X] \\cup [Y] \\cup [Z]\nIf we had multiple logical qubits, we would have three different cosets [X_i],[Y_i],[Z_i] for each logical qubit.\nParity check matrix\nThe Parity check matrix of the Steane’s code is:\n \\begin{aligned} \\bf{H} = \\left( \\begin{matrix} \\color{OrangeRed} 1 &amp; \\color{OrangeRed} 1 &amp; \\color{OrangeRed} 1 &amp; \\color{OrangeRed} 1 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\vert &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 \\\\ \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 1 &amp; \\color{RoyalBlue} 1 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 1 &amp; \\color{RoyalBlue} 1 &amp; \\color{RoyalBlue} 0 &amp; \\vert &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 \\\\ \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 1 &amp; \\color{ForestGreen} 1 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 1 &amp; \\color{ForestGreen} 1 &amp; \\vert &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 \\\\ \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\vert &amp; \\color{OrangeRed} 1 &amp; \\color{OrangeRed} 1 &amp; \\color{OrangeRed} 1 &amp; \\color{OrangeRed} 1 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 &amp; \\color{OrangeRed} 0 \\\\ \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 0 &amp; \\vert &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 1 &amp; \\color{RoyalBlue} 1 &amp; \\color{RoyalBlue} 0 &amp; \\color{RoyalBlue} 1 &amp; \\color{RoyalBlue} 1 &amp; \\color{RoyalBlue} 0 \\\\ \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\vert &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 1 &amp; \\color{ForestGreen} 1 &amp; \\color{ForestGreen} 0 &amp; \\color{ForestGreen} 1 &amp; \\color{ForestGreen} 1 \\\\ \\end{matrix} \\right) \\end{aligned}\nI have colored each row in accordance to the plaquette it corresponds to.\nDecoding\nAs an example of Decoding in stabilizer codes, let’s see how to decode a syndrome consisting of a single blue X-plaquette. Here are the two cosets of Z operators that fit this syndrome:\n\n\nThe first coset is constructed by taking the only single-qubit error that fits the syndrome, shown in the top-left triangle, and applying the seven Z stabilizers to it (blue, red, green, blue-red, blue-green, red-green, red-blue-green). The second coset is obtained in a similar way, starting with the two-qubit operator shown in the top-left triangle.\nAssuming an i.i.d noise, we can immediately solve the “first” decoding problem: the most likely error is the one of minimum weight, that is, the first error of coset 1. We can therefore choose any correction operator in this coset as our decoding solution.\nSolving the second decoding problem requires a bit more work. Let p be the probability that an error occurs on a given qubit, that is, the error rate of the noise channel. Each weight-k error has a probability\n\\pi_k = p^k (1-p)^{7-k}\nSumming the probabilities of all the elements, we get\n \\begin{aligned} P(\\text{coset 1}) &amp;= \\pi_1 + 4 \\pi_3 + 3 \\pi_5 \\\\ P(\\text{coset 2}) &amp;= 3 \\pi_2 + 4 \\pi_4 + \\pi_6 \\end{aligned}\nPlotting those two probabilities as a function of the error rate, we can see that the first coset always has a higher probability than the second one:\n\nThis can also be shown analytically by noticing that\n\\begin{aligned} P(\\text{coset 1}) - P(\\text{coset 2}) = p (1-p) (1-2p)^3 (2p^2 - 2p + 1) \\end{aligned}\nfrom which we can deduce that\nP(\\text{coset 1}) &gt; P(\\text{coset 2})\nfor\n 0 &lt; p &lt; \\frac{1}{2} \nTherefore, both decoding formulations give the first coset as our decoding solution.\nTanner graph\nThe Tanner graph of the Steane code is the following:\n\nThe fact that this graph contains two separate components (the X part and the Z part) is due to the CSS nature of the Steane code. In general, a stabilizer node can be connected to both X and Z qubit nodes."},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Surface-Code":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Surface-Code","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Surface Code.md","title":"Surface Code","links":["Quantum-Information/Quantum-Error-Correction/Codes","Quantum-Information/Foundations/Qubits","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Syndromes","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-gates","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-cosets","Quantum-Information/Quantum-Error-Correction/Logical-qubits","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Decoding-in-stabilizer-codes","tags/wip"],"tags":["wip"],"content":"Surface code on a torus\nThe surface code can be defined on a square grid of size L \\times L, where Qubits sit on the edges, as shown here for L=4:\n\nThe code is easier to analyze at first when considering periodic boundary conditions. Therefore, the grid is topologically equivalent to a torus.\nStabilizers\nThe stabilizer generators of the surface code look like this:\n\nwe have vertex stabilizers, defined on every vertex of the lattice as a cross of four Z operators, and plaquette stabilizers, defined on every face as a square of four X operators.\nTo define a valid code, X and Z stabilizers must commute. Since they are Pauli operators, it means that they must always intersect on an even number of qubits. We can check that this is the case here: vertex and plaquette operators always intersect on either zero or two qubits.\nStabilizer products always form a loop. This is clear for X stabilizers (plaquettes), eg:\n\nFor Z stabilizers (vertex) the loops are defined on a “perpendicular” grid, a so-called dual lattice:\n\n\nTherefore, all the properties we can derive for X stabilizers, errors and logicals can be directly translated to Z operators by simply considering the dual lattice, where Z operators behave exactly like X operators.\nIs the converse true, that is, do all the loops define stabilizers? Not always, they can be logical errors.\nDetectable errors\nAdding random X,Z errors on the lattice generates detectable errors when the resulting operator presents open paths, eg:\n\n\nThe highlighted vertices (in the normal or dual lattice) are part of the syndrome of the code; in fact, these vertices are touched by an odd number of X or Z operators, while vertices in a stabilizer are always touched by an even number of them.\nThe fact that excitations live at the boundary of error paths also means that when a path forms a loop, the excitations disappear. In other words, loops always commute with all the stabilizers, so they can be identified with the logical operators.\nLogical cosets and loops\nWe say that two loops \\ell_1,\\ell_2 on the surface code are equivalent if there exists a stabilizer S \\in \\mathcal{S} such that \\ell_1 = S \\ell_2, as seen in Logical cosets. For instance, if we consider X errors and X stabilizers, two loops of errors are equivalent if we can apply a series of plaquettes to go from one to the other.\nOperationally, two loops are equivalent if they correspond to the same logical operator. Therefore, by looking at all the equivalence classes of loops, we will be able to classify the different logical operators of the code.\nNow, we say that a loop is contractible, or trivial, if it is equivalent to the empty loop (no error). In other words, a loop is trivial if it is a stabilizer.\nLooping around the lattice twice always gives a trivial loop. This means that we have two non-trivial X loop coset (vertical and horizontal), two for Z and two for their combination (Y), then the quotient group has 4 generators ⇒ the surface code has 2 Logical qubits.\nNote that “vertical” X loops anticommute with “horizontal” Z loops, so those should act on the same logical qubit.\nDecoding\nSyndrome vertices always come in pairs\n\nthe corresponding error must be a string that links those two excitations. However, the number of strings that could have given this syndrome is very large.\nThe goal of the surface code decoding problem is to match the excitations such that the final operator is a stabilizer. Given the arbitrarity in the guessing of the error, we may fail in achieving this (i.e. when we apply our correction guess, we get a logical error).\nThe goal of decoding in general is to find a correction operator that belongs to the same coset as the actual error.\nIndeed, the product CE of the correction operator with the error is equal to a stabilizer if and only if there is a stabilizer S such that C=ES, that is, if C and E belong to the same class. To solve this problem with the information we have, that is, only the syndrome and the error probabilities, the optimal decoding problem, also called maximum-likelihood decoding, can be formulated as finding the coset \\bf{\\bar{C}} with the highest probability:\n \\max_{\\bf{\\bar{C}}} P(\\bf{\\bar{C}}) \nwhere P(\\bf{\\bar{C}}) can be calculated as a sum over all the operators in the coset: P(\\bf{\\bar{C}}) = \\sum_{\\bf{C} \\in \\bf{\\bar{C}}} P(\\bf{C}).\nSolving this problem exactly is computationally very hard, as it requires calculating a sum over an exponential number of terms (in the size of the lattice). But for the surface code, it can be approximated very well using tensor network decoders, which have a complexity of O(n \\chi^3) (up to some logarithmic factor), with n the number of qubits and \\chi a parameter quantifying the degree of approximation of the decoder (corresponding to the bound dimension of the tensor network). The main downside of this decoder is that it generalizes poorly to the case of imperfect syndrome measurements. In this case, measurements need to be repeated in time, leading to a 3D decoding problem that tensor networks cannot solve efficiently at the moment.\nThe maximum-likelihood decoding problem can also be approximated by solving for the error with the highest probability, instead of the whole coset. Assuming i.i.d. noise, finding the error with the highest probability is equivalent to finding the smallest error that fits the syndrome. In the case of the surface code, this corresponds to matching the excitations with chains of minimum weight.\nAs it happens, this is completely equivalent to solving a famous graph problem, known as minimum-weight perfect matching.\nThis problem can be expressed as matching all the vertices of a weighted graph (with an even number of vertices), such that the total weight is minimized. In our case, the graph is constructed as a complete graph with a vertex for each excitation. The weight of each edge between two vertices is then given by the Manhattan distance between the two corresponding excitations. For instance, let’s consider the following decoding problem:\n\nThe associated graph is then the following:\n\nBy enumerating all the possible matchings, you can quickly see that the one of minimum weight links vertices 1 and 2, and 3 and 4, with a total weight of 5:\n\nFrom there, we can deduce our decoding solution:\n\nIt happens that minimum-weight perfect-matching can be solved in polynomial time using the Blossom algorithm, which has a worst-case complexity of O(n^3). While this complexity might seem quite high, a recent modification of the Blossom algorithm, proposed by Oscar Higgott and Craig Gidney, seems to have an average complexity of O(n). It also generalizes very well to the imperfect syndrome case, making it one of the best decoders out there in terms of trade-off between speed and performance (the performance will be reviewed when talking about thresholds in the last section of the post).\nSurface code on open boundaries\nConsider the following version of the surface code, where vertex stabilizers on the top and bottom boundaries, and plaquette stabilizers on the left and right boundaries, are now supported on three qubits instead of four:\n\nWe call the top and bottom boundaries smooth boundaries, and the left and right boundaries rough boundaries.\nSingle vertex excitations can now be created starting from the boundaries. This poses a slight issue when decoding using minimum-weight perfect matching, but this can easily be overcome by adding some new boundary nodes to the matching graph.\nX logicals have to join the rough boundaries, and Z logicals have to join the smooth boundaries.\nTherefore, there are only two equivalence classes of logicals for each error type: the strings that join opposite boundaries, and the trivial loops. As a consequence, this non-periodic version of the surface code, also called planar code, only encodes a single qubit. It is a [2L^2 - 2L + 1, 1, L]-code. While we have lost one qubit compared to the toric version, the fact that it can be laid out on a 2D surface makes it much more practical.\nRotated surface\nMore commonly in the literature we find a rotated version of the surface code:\n\nWhere, for each vertex, we can add X errors on the yellow faces and Z errors on the red faces.\nThe idea is to turn every edge of the original representation into a vertex, each vertex into yellow face, and each face into a red face. This representation is called the rectified lattice.\nOne advantage of this representation is that it allows to come up with a different, more compact, version of the surface code. The idea is to take to following central piece of the rectified lattice:\n\nWe then rotate it and add a few boundary stabilizers. This gives the following code, called the rotated surface code:\n\nThe rotated surface code is a [[L^2, 1, L]]-code, which is a factor two improvement in the overhead compared to the original surface code. This version of the surface code is therefore the preferred one to realize experimentally. For instance, its two smallest instances, the [[9,1,3]] code and the [[16,1,4]] code are the ones recently realized by the Google lab.\nThresholds\nwip"},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Syndromes":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Syndromes","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Syndromes.md","title":"Syndromes","links":["Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Stabilizer-code","Quantum-Information/Quantum-Error-Correction/Codes","Quantum-Information/Foundations/Pauli-operators","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Logical-gates","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Binary-symplectic-format","Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Parity-check-matrix","Quantum-Information/Quantum-Computation/CNOT-gate","Quantum-Information/Quantum-Computation/Hadamard-Gate"],"tags":[],"content":"Error syndromes in the stabilizer formalism record when an element of the codespace is transformed under a Pauli operator E which anticommutes with some generator S_i of the stabilizer group \\mathcal{S}. Therefore, for a stabilizer group with m independent generators, we define the error syndrome for the error E as a m-dimensional vector s whose i-th component is found using:\ns_i = \\left\\{\\begin{array}{ll}\n1&amp; \\textrm{if } \\anticomm{S_i}{E} = 0\\\\\n0 &amp;\\textrm{if } \\comm{S_i}{E} = 0\n\\end{array}\\right.\nNote that we do not expect to be able to detect logical errors, which is coherent with the notion of distance for a code\nError detection\nIf a detectable error (in Binary symplectic format) \\underline{e} occurs, then a syndrome \\underline{s} must satisfy the parity check constraint:\nH\\odot\\underline{e} = \\underline{s}\nwhich, given what is discussed above, makes perfect sense.\nHow to measure syndromes\nHow can syndromes be measured in practice? We use CNOT gates to prepare a set of auxiliary qubits, upon which we perform measurements on the Z or X (we can use an Hadamard Gate to measure on Z anyway) bases. See syndrome extraction for more details.\n#wip"},"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Tanner-graphs":{"slug":"Quantum-Information/Quantum-Error-Correction/Stabilizer-formalism/Tanner-graphs","filePath":"../PhysicsVault/Quantum Information/Quantum Error Correction/Stabilizer formalism/Tanner graphs.md","title":"Tanner graphs","links":[],"tags":[],"content":"Many methods to design quantum codes and decoders work by representing stabilizer codes using their so-called Tanner graph. The Tanner graph of a code associated to an m \\times 2n parity-check matrix H is built by creating 2n+m nodes: two nodes per qubit (one for X errors and one for Z errors), and one node per stabilizer. By convention, qubit nodes are often represented by circles and stabilizer nodes by squares. Each stabilizer node is then connected to the qubits in its support (with the right Pauli operators). In other words, H is the biadjacency matrix of the Tanner graph."},"Quantum-Information/TODO":{"slug":"Quantum-Information/TODO","filePath":"../PhysicsVault/Quantum Information/TODO.md","title":"TODO","links":[],"tags":[],"content":"\nStabilizer formalism\nEntanglement monogamy\npure state distance, 20210129\nfidelities from holevo, check fidelity file\nchannel representation invariance\nEntanglement distillation 20220225\npipeline\nteleportation covariance\nFunction gate: relative phases link\nchange registry to register\nOrder finding (chuang)\nFourier transform and series\nperiod finding generalization\nOptimal encoding\n"},"index":{"slug":"index","filePath":"../PhysicsVault/index.md","title":"index","links":[],"tags":[],"content":"Welcome to my second brain! (very much wip)\nTable of contents coming soon, use the explorer on the left for now."}}